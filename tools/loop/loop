#!/usr/bin/env bash
#===============================================================================
#                           LOOP - The Core Iteration Primitive
#                                   Daedalos OS
#===============================================================================
#
# "A loop is not a feature. A loop is how intelligent work gets done."
#
# Usage:
#   loop start <prompt> --promise <cmd>    Start a new loop
#   loop status [id]                       Show loop status
#   loop watch <id>                        Watch loop execution
#   loop pause <id>                        Pause a loop
#   loop resume <id>                       Resume a paused loop
#   loop cancel <id>                       Cancel a loop
#   loop inject <id> <context>             Inject context
#   loop checkpoint <id> [name]            Create checkpoint
#   loop rollback <id> <checkpoint>        Rollback to checkpoint
#   loop history <id>                      Show iteration history
#   loop list                              List all loops
#   loop template list|show|create         Manage templates
#   loop workflow run <file>               Run workflow
#
#===============================================================================

set -euo pipefail

# Version
LOOP_VERSION="1.0.0"

# Directories
LOOP_STATE_DIR="${XDG_DATA_HOME:-$HOME/.local/share}/daedalos/loop"
LOOP_CONFIG_DIR="${XDG_CONFIG_HOME:-$HOME/.config}/daedalos/loop"
LOOP_TEMPLATES_DIR="${LOOP_TEMPLATES_DIR:-$(dirname "$0")/templates}"
LOOPD_SOCKET="${LOOPD_SOCKET:-/run/daedalos/loopd.sock}"

# Find the lib directory relative to this script
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
LOOP_LIB_DIR="$SCRIPT_DIR/lib"

# Ensure directories exist
mkdir -p "$LOOP_STATE_DIR" "$LOOP_CONFIG_DIR"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
BOLD='\033[1m'
NC='\033[0m' # No Color

#-------------------------------------------------------------------------------
# Utility Functions
#-------------------------------------------------------------------------------

log_info() {
    echo -e "${BLUE}[INFO]${NC} $*"
}

log_success() {
    echo -e "${GREEN}[OK]${NC} $*"
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $*"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $*" >&2
}

die() {
    log_error "$@"
    exit 1
}

# Check if Python 3 is available
check_python() {
    if ! command -v python3 &>/dev/null; then
        die "Python 3 is required but not found"
    fi
}

# Run Python with the loop library
run_python() {
    PYTHONPATH="$SCRIPT_DIR:${PYTHONPATH:-}" python3 "$@"
}

#-------------------------------------------------------------------------------
# Command: start
#-------------------------------------------------------------------------------

cmd_start() {
    local prompt=""
    local promise=""
    local max_iterations=10
    local agent="auto"
    local agent_cmd=""
    local checkpoint="auto"
    local timeout=300
    local best_of=0
    local template=""
    local inject_file=""
    local background=false
    local notify=false

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --promise|-p)
                promise="$2"
                shift 2
                ;;
            --max-iterations|-n)
                max_iterations="$2"
                shift 2
                ;;
            --agent)
                agent="$2"
                shift 2
                ;;
            --agent-cmd)
                agent_cmd="$2"
                shift 2
                ;;
            --checkpoint)
                checkpoint="$2"
                shift 2
                ;;
            --timeout)
                timeout="$2"
                shift 2
                ;;
            --best-of)
                best_of="$2"
                shift 2
                ;;
            --template)
                template="$2"
                shift 2
                ;;
            --inject)
                inject_file="$2"
                shift 2
                ;;
            --background|-b)
                background=true
                shift
                ;;
            --notify)
                notify=true
                shift
                ;;
            --help|-h)
                cmd_start_help
                exit 0
                ;;
            -*)
                die "Unknown option: $1"
                ;;
            *)
                if [[ -z "$prompt" ]]; then
                    prompt="$1"
                else
                    prompt="$prompt $1"
                fi
                shift
                ;;
        esac
    done

    # Validate required arguments
    if [[ -z "$prompt" ]]; then
        die "Missing required argument: <prompt>"
    fi
    if [[ -z "$promise" ]]; then
        die "Missing required argument: --promise <cmd>"
    fi

    # Run the start command via Python
    run_python -c "
import sys
sys.path.insert(0, '$SCRIPT_DIR')

from lib.state import Loop, LoopStatus
from lib.agent import get_agent, detect_agent
from lib.checkpoint import get_backend
from lib.bestofn import run_best_of_n
from lib.notify import notify_loop_complete
from pathlib import Path
import json

prompt = '''$prompt'''
promise = '''$promise'''
max_iterations = $max_iterations
agent_name = '$agent'
agent_cmd = '$agent_cmd' if '$agent_cmd' else None
checkpoint_strategy = '$checkpoint'
timeout = $timeout
best_of = $best_of
do_notify = $([[ "$notify" == "true" ]] && echo "True" || echo "False")
working_dir = Path.cwd()

# Get agent
if agent_name == 'auto':
    agent = detect_agent()
    if not agent:
        print('ERROR: No agent available. Install opencode, claude, or aider.', file=sys.stderr)
        sys.exit(1)
elif agent_name == 'custom':
    if not agent_cmd:
        print('ERROR: --agent custom requires --agent-cmd', file=sys.stderr)
        sys.exit(1)
    from lib.agent import CustomAgent
    agent = CustomAgent(agent_cmd)
else:
    agent = get_agent(agent_name)

# Get checkpoint backend
checkpoint = get_backend(working_dir, checkpoint_strategy)

print(f'Starting loop with {agent.name} agent and {checkpoint.name} checkpoints')
print(f'Promise: {promise}')
print(f'Max iterations: {max_iterations}')
print()

def on_iteration(iteration):
    status = 'PASS' if iteration.promise_result else 'FAIL'
    print(f'[Iteration {iteration.number}] {status} ({iteration.duration_ms}ms)')
    if not iteration.promise_result and iteration.promise_output:
        # Show first few lines of output
        lines = iteration.promise_output.strip().split('\\n')[:5]
        for line in lines:
            print(f'  {line}')

if best_of > 0:
    # Best-of-N mode
    print(f'Running {best_of} parallel branches...')
    result = run_best_of_n(
        prompt=prompt,
        promise_cmd=promise,
        working_dir=working_dir,
        n=best_of,
        agent_name=agent.name,
        max_iterations=max_iterations,
        timeout=timeout
    )
    if result.winner:
        print(f'\\nWinner: Branch {result.winner.branch_id + 1}')
        print(f'Score: {result.winner.score:.1f}')
        print(f'Iterations: {result.winner.iterations_used}')
        if result.winner.success:
            print('\\nPromise satisfied!')
            sys.exit(0)
    sys.exit(1)
else:
    # Normal mode
    loop = Loop(
        prompt=prompt,
        promise_cmd=promise,
        working_dir=working_dir,
        agent=agent,
        checkpoint=checkpoint,
        max_iterations=max_iterations,
        timeout=timeout,
        on_iteration=on_iteration
    )

    print(f'Loop ID: {loop.state.id}')
    print()

    success = loop.run()

    print()
    if success:
        print(f'Loop completed in {loop.state.current_iteration} iterations')
        if do_notify:
            notify_loop_complete(loop.state.id, prompt, loop.state.current_iteration, True)
        sys.exit(0)
    else:
        print(f'Loop failed after {loop.state.current_iteration} iterations')
        if loop.state.error_message:
            print(f'Error: {loop.state.error_message}')
        if do_notify:
            notify_loop_complete(loop.state.id, prompt, loop.state.current_iteration, False)
        sys.exit(1)
"
}

cmd_start_help() {
    cat << 'EOF'
Usage: loop start <prompt> --promise <cmd> [options]

Start a new loop that iterates until the promise is met.

Arguments:
  <prompt>                  Natural language description of the task

Required:
  --promise, -p <cmd>       Shell command that returns 0 when task is complete

Options:
  --max-iterations, -n <num>    Maximum iterations (default: 10)
  --agent <name>                Agent: opencode|claude|aider|custom|auto
  --agent-cmd <cmd>             Custom agent command (with --agent custom)
  --checkpoint <strategy>       Checkpoint: btrfs|git|none|auto
  --timeout <seconds>           Per-iteration timeout (default: 300)
  --best-of <n>                 Run N parallel branches, pick best
  --template <name>             Use a predefined template
  --inject <file>               Inject context from file
  --background, -b              Run in background
  --notify                      Send notification on completion

Examples:
  loop start "fix failing tests" --promise "npm test"
  loop start "add user auth" -p "./verify.sh" -n 20
  loop start "optimize queries" -p "make bench" --best-of 3
EOF
}

#-------------------------------------------------------------------------------
# Command: status
#-------------------------------------------------------------------------------

cmd_status() {
    local loop_id="${1:-}"
    local watch=false
    local json_output=false

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --watch|-w)
                watch=true
                shift
                ;;
            --json)
                json_output=true
                shift
                ;;
            -*)
                shift
                ;;
            *)
                loop_id="$1"
                shift
                ;;
        esac
    done

    run_python -c "
import sys
sys.path.insert(0, '$SCRIPT_DIR')

from lib.state import list_loops, get_loop, LoopStatus
import json

loop_id = '$loop_id' if '$loop_id' else None
json_output = $([[ "$json_output" == "true" ]] && echo "True" || echo "False")

if loop_id:
    # Show specific loop
    state = get_loop(loop_id)
    if not state:
        print(f'Loop not found: {loop_id}', file=sys.stderr)
        sys.exit(1)

    if json_output:
        print(json.dumps(state.to_dict(), indent=2))
    else:
        print(f'Loop: {state.id}')
        print(f'Status: {state.status.value}')
        print(f'Prompt: {state.prompt[:60]}...' if len(state.prompt) > 60 else f'Prompt: {state.prompt}')
        print(f'Promise: {state.promise_cmd}')
        print(f'Iterations: {state.current_iteration}/{state.max_iterations}')
        print(f'Agent: {state.agent_name}')
        print(f'Created: {state.created_at}')
        print(f'Updated: {state.updated_at}')
else:
    # List all loops
    loops = list_loops()

    if json_output:
        print(json.dumps([s.to_dict() for s in loops], indent=2))
    else:
        if not loops:
            print('No loops found')
        else:
            print(f\"{'ID':<12} {'STATUS':<12} {'ITER':<8} {'PROMISE':<30} {'AGENT':<10}\")
            print('-' * 80)
            for state in loops[:20]:
                promise = state.promise_cmd[:28] + '..' if len(state.promise_cmd) > 30 else state.promise_cmd
                print(f'{state.id:<12} {state.status.value:<12} {state.current_iteration}/{state.max_iterations:<5} {promise:<30} {state.agent_name:<10}')
"
}

#-------------------------------------------------------------------------------
# Command: watch
#-------------------------------------------------------------------------------

cmd_watch() {
    local loop_id="${1:-}"

    if [[ -z "$loop_id" ]]; then
        die "Usage: loop watch <loop-id>"
    fi

    # For now, just show status repeatedly
    # Full implementation would stream live output
    echo "Watching loop $loop_id (Ctrl+C to stop)"
    echo "Press: p=pause, r=resume, c=checkpoint, x=cancel, q=quit"
    echo

    while true; do
        clear
        cmd_status "$loop_id" || break
        sleep 2
    done
}

#-------------------------------------------------------------------------------
# Command: pause
#-------------------------------------------------------------------------------

cmd_pause() {
    local loop_id="${1:-}"
    if [[ -z "$loop_id" ]]; then
        die "Usage: loop pause <loop-id>"
    fi

    run_python -c "
import sys
sys.path.insert(0, '$SCRIPT_DIR')
from lib.state import get_loop, LoopStatus

state = get_loop('$loop_id')
if not state:
    print('Loop not found', file=sys.stderr)
    sys.exit(1)

if state.status != LoopStatus.RUNNING:
    print(f'Loop is not running (status: {state.status.value})', file=sys.stderr)
    sys.exit(1)

state.status = LoopStatus.PAUSED
from pathlib import Path
state.save(Path.home() / '.local/share/daedalos/loop/states')
print(f'Loop {state.id} paused')
"
}

#-------------------------------------------------------------------------------
# Command: resume
#-------------------------------------------------------------------------------

cmd_resume() {
    local loop_id="${1:-}"
    if [[ -z "$loop_id" ]]; then
        die "Usage: loop resume <loop-id>"
    fi

    run_python -c "
import sys
sys.path.insert(0, '$SCRIPT_DIR')
from lib.state import Loop, get_loop, LoopStatus
from lib.agent import get_agent
from lib.checkpoint import get_backend
from pathlib import Path

state = get_loop('$loop_id')
if not state:
    print('Loop not found', file=sys.stderr)
    sys.exit(1)

if state.status != LoopStatus.PAUSED:
    print(f'Loop is not paused (status: {state.status.value})', file=sys.stderr)
    sys.exit(1)

# Resume the loop
working_dir = Path(state.working_dir)
agent = get_agent(state.agent_name)
checkpoint = get_backend(working_dir)

loop = Loop.resume_from_state(state, agent, checkpoint)
print(f'Resuming loop {state.id}...')
success = loop.run()

if success:
    print(f'Loop completed in {loop.state.current_iteration} iterations')
else:
    print(f'Loop failed after {loop.state.current_iteration} iterations')
    sys.exit(1)
"
}

#-------------------------------------------------------------------------------
# Command: cancel
#-------------------------------------------------------------------------------

cmd_cancel() {
    local loop_id="${1:-}"
    local rollback=false

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --rollback)
                rollback=true
                shift
                ;;
            *)
                loop_id="$1"
                shift
                ;;
        esac
    done

    if [[ -z "$loop_id" ]]; then
        die "Usage: loop cancel <loop-id> [--rollback]"
    fi

    run_python -c "
import sys
sys.path.insert(0, '$SCRIPT_DIR')
from lib.state import get_loop, LoopStatus
from lib.checkpoint import get_backend
from pathlib import Path

state = get_loop('$loop_id')
if not state:
    print('Loop not found', file=sys.stderr)
    sys.exit(1)

rollback = $([[ "$rollback" == "true" ]] && echo "True" || echo "False")

if rollback and state.initial_checkpoint:
    working_dir = Path(state.working_dir)
    checkpoint = get_backend(working_dir)
    if checkpoint.restore(state.initial_checkpoint, working_dir):
        print('Rolled back to initial state')
    else:
        print('Warning: Could not rollback', file=sys.stderr)

state.status = LoopStatus.CANCELLED
state.save(Path.home() / '.local/share/daedalos/loop/states')
print(f'Loop {state.id} cancelled')
"
}

#-------------------------------------------------------------------------------
# Command: inject
#-------------------------------------------------------------------------------

cmd_inject() {
    local loop_id="${1:-}"
    shift || true
    local context="$*"
    local from_file=""

    # Check for --file flag
    if [[ "${1:-}" == "--file" ]]; then
        from_file="${2:-}"
        if [[ -z "$from_file" ]]; then
            die "Usage: loop inject <loop-id> --file <path>"
        fi
        context=$(cat "$from_file")
    elif [[ "${1:-}" == "-" ]]; then
        # Read from stdin
        context=$(cat)
    fi

    if [[ -z "$loop_id" ]]; then
        die "Usage: loop inject <loop-id> <context>"
    fi
    if [[ -z "$context" ]]; then
        die "No context provided"
    fi

    run_python -c "
import sys
sys.path.insert(0, '$SCRIPT_DIR')
from lib.state import get_loop
from pathlib import Path

state = get_loop('$loop_id')
if not state:
    print('Loop not found', file=sys.stderr)
    sys.exit(1)

context = '''$context'''
state.injected_context.append(context)
state.save(Path.home() / '.local/share/daedalos/loop/states')
print(f'Context injected into loop {state.id}')
"
}

#-------------------------------------------------------------------------------
# Command: checkpoint
#-------------------------------------------------------------------------------

cmd_checkpoint() {
    local loop_id="${1:-}"
    local name="${2:-}"

    if [[ -z "$loop_id" ]]; then
        die "Usage: loop checkpoint <loop-id> [name]"
    fi

    run_python -c "
import sys
sys.path.insert(0, '$SCRIPT_DIR')
from lib.state import get_loop
from lib.checkpoint import get_backend
from pathlib import Path

state = get_loop('$loop_id')
if not state:
    print('Loop not found', file=sys.stderr)
    sys.exit(1)

working_dir = Path(state.working_dir)
checkpoint = get_backend(working_dir)

name = '$name' if '$name' else f'manual_{state.current_iteration}'
checkpoint_id = checkpoint.create(name, working_dir)
print(f'Checkpoint created: {checkpoint_id}')
"
}

#-------------------------------------------------------------------------------
# Command: rollback
#-------------------------------------------------------------------------------

cmd_rollback() {
    local loop_id="${1:-}"
    local checkpoint="${2:-}"

    if [[ -z "$loop_id" ]] || [[ -z "$checkpoint" ]]; then
        die "Usage: loop rollback <loop-id> <checkpoint>"
    fi

    run_python -c "
import sys
sys.path.insert(0, '$SCRIPT_DIR')
from lib.state import get_loop
from lib.checkpoint import get_backend
from pathlib import Path

state = get_loop('$loop_id')
if not state:
    print('Loop not found', file=sys.stderr)
    sys.exit(1)

working_dir = Path(state.working_dir)
checkpoint_backend = get_backend(working_dir)

checkpoint_id = '$checkpoint'
if checkpoint_id == 'initial':
    checkpoint_id = state.initial_checkpoint

if checkpoint_backend.restore(checkpoint_id, working_dir):
    print(f'Rolled back to {checkpoint_id}')
else:
    print('Rollback failed', file=sys.stderr)
    sys.exit(1)
"
}

#-------------------------------------------------------------------------------
# Command: history
#-------------------------------------------------------------------------------

cmd_history() {
    local loop_id="${1:-}"
    local verbose=false

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --verbose|-v)
                verbose=true
                shift
                ;;
            *)
                loop_id="$1"
                shift
                ;;
        esac
    done

    if [[ -z "$loop_id" ]]; then
        die "Usage: loop history <loop-id>"
    fi

    run_python -c "
import sys
sys.path.insert(0, '$SCRIPT_DIR')
from lib.state import get_loop

state = get_loop('$loop_id')
if not state:
    print('Loop not found', file=sys.stderr)
    sys.exit(1)

verbose = $([[ "$verbose" == "true" ]] && echo "True" || echo "False")

print(f\"{'ITER':<6} {'CHECKPOINT':<25} {'RESULT':<8} {'DURATION':<10} {'CHANGES'}\")
print('-' * 80)

for iteration in state.iterations:
    result = 'PASS' if iteration.promise_result else 'FAIL'
    duration = f'{iteration.duration_ms}ms'
    checkpoint = iteration.checkpoint_id[:23] + '..' if len(iteration.checkpoint_id) > 25 else iteration.checkpoint_id
    changes = iteration.changes_summary.split('\\n')[0][:20] if iteration.changes_summary else 'N/A'

    print(f'{iteration.number:<6} {checkpoint:<25} {result:<8} {duration:<10} {changes}')

    if verbose and iteration.promise_output:
        print(f'  Output: {iteration.promise_output[:100]}...')
"
}

#-------------------------------------------------------------------------------
# Command: list
#-------------------------------------------------------------------------------

cmd_list() {
    cmd_status "$@"
}

#-------------------------------------------------------------------------------
# Command: template
#-------------------------------------------------------------------------------

cmd_template() {
    local subcmd="${1:-list}"
    shift || true

    case "$subcmd" in
        list)
            echo "Available templates:"
            echo
            for template in "$LOOP_TEMPLATES_DIR"/*.yaml; do
                if [[ -f "$template" ]]; then
                    name=$(basename "$template" .yaml)
                    echo "  $name"
                fi
            done
            ;;
        show)
            local name="${1:-}"
            if [[ -z "$name" ]]; then
                die "Usage: loop template show <name>"
            fi
            local template_file="$LOOP_TEMPLATES_DIR/$name.yaml"
            if [[ ! -f "$template_file" ]]; then
                die "Template not found: $name"
            fi
            cat "$template_file"
            ;;
        create)
            local name="${1:-}"
            if [[ -z "$name" ]]; then
                die "Usage: loop template create <name>"
            fi
            local template_file="$LOOP_TEMPLATES_DIR/$name.yaml"
            if [[ -f "$template_file" ]]; then
                die "Template already exists: $name"
            fi
            cat > "$template_file" << 'TEMPLATE'
name: new-template
description: Description of this template

defaults:
  max_iterations: 10

stages:
  - name: stage1
    prompt: "First stage task"
    promise: "echo 'replace with your command'"
    max_iterations: 5

  - name: stage2
    prompt: "Second stage task"
    promise: "echo 'replace with your command'"
    depends_on: [stage1]
    max_iterations: 5
TEMPLATE
            echo "Created template: $template_file"
            echo "Edit it to customize."
            ;;
        *)
            die "Unknown template command: $subcmd"
            ;;
    esac
}

#-------------------------------------------------------------------------------
# Command: workflow
#-------------------------------------------------------------------------------

cmd_workflow() {
    local subcmd="${1:-}"
    shift || true

    case "$subcmd" in
        run)
            local workflow_file="${1:-}"
            if [[ -z "$workflow_file" ]]; then
                die "Usage: loop workflow run <file> [--set key=value ...]"
            fi
            shift

            # Parse --set arguments
            local vars=""
            while [[ $# -gt 0 ]]; do
                case "$1" in
                    --set)
                        vars="$vars $2"
                        shift 2
                        ;;
                    *)
                        shift
                        ;;
                esac
            done

            run_python -c "
import sys
sys.path.insert(0, '$SCRIPT_DIR')
from lib.workflow import load_workflow, WorkflowRunner
from pathlib import Path

workflow_file = Path('$workflow_file')
if not workflow_file.exists():
    print(f'Workflow file not found: {workflow_file}', file=sys.stderr)
    sys.exit(1)

# Parse variables
variables = {}
for var in '$vars'.split():
    if '=' in var:
        k, v = var.split('=', 1)
        variables[k] = v

workflow = load_workflow(workflow_file, variables)
print(f'Running workflow: {workflow.name}')
print(f'Description: {workflow.description}')
print(f'Loops: {len(workflow.loops)}')
print()

def on_loop_start(loop_id):
    print(f'Starting loop: {loop_id}')

def on_loop_complete(loop_id, success):
    status = 'PASS' if success else 'FAIL'
    print(f'Loop {loop_id}: {status}')

runner = WorkflowRunner(
    workflow=workflow,
    working_dir=Path.cwd(),
    on_loop_start=on_loop_start,
    on_loop_complete=on_loop_complete
)

success = runner.run()
if success:
    print('\\nWorkflow completed successfully!')
else:
    print('\\nWorkflow failed', file=sys.stderr)
    sys.exit(1)
"
            ;;
        list)
            echo "Workflow files in templates:"
            for wf in "$LOOP_TEMPLATES_DIR"/*.yaml; do
                if [[ -f "$wf" ]]; then
                    basename "$wf"
                fi
            done
            ;;
        *)
            die "Usage: loop workflow run <file> | list"
            ;;
    esac
}

#-------------------------------------------------------------------------------
# Command: version
#-------------------------------------------------------------------------------

cmd_version() {
    echo "loop $LOOP_VERSION"
    echo "Part of Daedalos - The AI-Native Development OS"
}

#-------------------------------------------------------------------------------
# Command: help
#-------------------------------------------------------------------------------

cmd_help() {
    cat << 'EOF'
loop - The core iteration primitive of Daedalos

"A loop is not a feature. A loop is how intelligent work gets done."

Usage:
  loop <command> [arguments]

Commands:
  start <prompt> -p <cmd>    Start a new loop
  status [id]                Show loop status
  watch <id>                 Watch loop execution live
  pause <id>                 Pause a running loop
  resume <id>                Resume a paused loop
  cancel <id>                Cancel a loop
  inject <id> <context>      Inject context into loop
  checkpoint <id> [name]     Create named checkpoint
  rollback <id> <checkpoint> Rollback to checkpoint
  history <id>               Show iteration history
  list                       List all loops
  template list|show|create  Manage loop templates
  workflow run <file>        Run multi-loop workflow
  version                    Show version
  help                       Show this help

Examples:
  loop start "fix tests" --promise "npm test"
  loop start "add auth" -p "./verify.sh" -n 20 --agent claude
  loop start "optimize" -p "make bench" --best-of 3
  loop status
  loop watch abc123
  loop inject abc123 "focus on UserService"
  loop rollback abc123 initial

For more information on a command:
  loop <command> --help
EOF
}

#-------------------------------------------------------------------------------
# Main
#-------------------------------------------------------------------------------

main() {
    check_python

    case "${1:-help}" in
        start)      shift; cmd_start "$@" ;;
        status)     shift; cmd_status "$@" ;;
        watch)      shift; cmd_watch "$@" ;;
        pause)      shift; cmd_pause "$@" ;;
        resume)     shift; cmd_resume "$@" ;;
        cancel)     shift; cmd_cancel "$@" ;;
        inject)     shift; cmd_inject "$@" ;;
        checkpoint) shift; cmd_checkpoint "$@" ;;
        rollback)   shift; cmd_rollback "$@" ;;
        history)    shift; cmd_history "$@" ;;
        list)       shift; cmd_list "$@" ;;
        template)   shift; cmd_template "$@" ;;
        workflow)   shift; cmd_workflow "$@" ;;
        version|--version|-v)  cmd_version ;;
        help|--help|-h)        cmd_help ;;
        *)
            log_error "Unknown command: $1"
            cmd_help
            exit 1
            ;;
    esac
}

main "$@"
