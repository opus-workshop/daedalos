================================================================================
                       MCP-HUB - ONE-SHOT BUILD PROMPT
================================================================================

You are building the `mcp-hub` tool for Daedalos, a Linux distribution designed
for AI-assisted development. MCP-Hub is a central manager for Model Context
Protocol servers.

================================================================================
                              WHAT YOU'RE BUILDING
================================================================================

MCP-Hub manages MCP servers system-wide:
- Discovers and catalogs available servers
- Starts/stops servers on demand
- Routes tool requests to appropriate servers
- Provides unified capability discovery

Instead of configuring MCP servers per-project, mcp-hub manages them centrally.

================================================================================
                              ARCHITECTURE
================================================================================

Create these files:

mcp-hub/
├── mcp-hub                   # Main CLI entry point (Bash)
├── mcphub/
│   ├── __init__.py
│   ├── daemon.py             # Hub daemon
│   ├── registry.py           # Server registry
│   ├── pool.py               # Server pool management
│   ├── router.py             # Request routing
│   ├── config.py             # Configuration handling
│   └── auth.py               # Authentication management
├── servers/                  # Built-in server definitions
│   ├── filesystem.yaml
│   ├── github.yaml
│   └── memory.yaml
├── completions/
│   └── mcp-hub.bash
└── tests/
    └── test_hub.py

================================================================================
                              MAIN CLI (mcp-hub)
================================================================================

```bash
#!/usr/bin/env bash
# mcp-hub - MCP Server Hub for Daedalos

set -euo pipefail

MCPHUB_VERSION="1.0.0"
MCPHUB_CONFIG="${XDG_CONFIG_HOME:-$HOME/.config}/daedalos/mcp-hub"
MCPHUB_DATA="${XDG_DATA_HOME:-$HOME/.local/share}/daedalos/mcp-hub"
MCPHUB_SOCKET="${MCPHUB_SOCKET:-/run/daedalos/mcp-hub.sock}"

mkdir -p "$MCPHUB_CONFIG" "$MCPHUB_DATA"

cmd_start() {
    echo "Starting MCP Hub..."
    python3 -m mcphub.daemon start "$@"
}

cmd_stop() {
    python3 -m mcphub.daemon stop
}

cmd_status() {
    python3 -m mcphub.daemon status "$@"
}

cmd_list() {
    python3 -m mcphub.registry list "$@"
}

cmd_install() {
    python3 -m mcphub.registry install "$@"
}

cmd_tools() {
    python3 -m mcphub.registry tools "$@"
}

cmd_call() {
    python3 -m mcphub.router call "$@"
}

cmd_config() {
    python3 -m mcphub.config "$@"
}

main() {
    case "${1:-help}" in
        start)      shift; cmd_start "$@" ;;
        stop)       shift; cmd_stop "$@" ;;
        status)     shift; cmd_status "$@" ;;
        list)       shift; cmd_list "$@" ;;
        search)     shift; cmd_search "$@" ;;
        install)    shift; cmd_install "$@" ;;
        uninstall)  shift; cmd_uninstall "$@" ;;
        update)     shift; cmd_update "$@" ;;
        enable)     shift; cmd_enable "$@" ;;
        disable)    shift; cmd_disable "$@" ;;
        config)     shift; cmd_config "$@" ;;
        tools)      shift; cmd_tools "$@" ;;
        resources)  shift; cmd_resources "$@" ;;
        prompts)    shift; cmd_prompts "$@" ;;
        call)       shift; cmd_call "$@" ;;
        logs)       shift; cmd_logs "$@" ;;
        restart)    shift; cmd_restart "$@" ;;
        warm)       shift; cmd_warm "$@" ;;
        auth)       shift; cmd_auth "$@" ;;
        version)    echo "mcp-hub $MCPHUB_VERSION" ;;
        help|--help|-h) cmd_help ;;
        *)          echo "Unknown command: $1"; exit 1 ;;
    esac
}

main "$@"
```

================================================================================
                              DAEMON (daemon.py)
================================================================================

```python
"""MCP Hub Daemon - manages server pool and routes requests."""

import asyncio
import json
from pathlib import Path
from typing import Optional
import signal
import sys

# MCP SDK imports
try:
    from mcp import Server, ServerSession
    from mcp.types import Tool, Resource
except ImportError:
    print("MCP SDK not installed. Run: pip install mcp")
    sys.exit(1)


class MCPHubDaemon:
    """Central hub daemon for MCP servers."""

    def __init__(self, config_path: Path, socket_path: Path):
        self.config_path = config_path
        self.socket_path = socket_path
        self.servers: dict[str, ServerProcess] = {}
        self.running = False

    async def start(self):
        """Start the hub daemon."""
        self.running = True

        # Load configuration
        config = self._load_config()

        # Start auto-start servers
        for name, server_config in config.get("servers", {}).items():
            if server_config.get("auto_start", False):
                await self._start_server(name, server_config)

        # Listen for requests
        await self._listen()

    async def stop(self):
        """Stop the daemon and all managed servers."""
        self.running = False

        # Stop all servers
        for name, server in self.servers.items():
            await self._stop_server(name)

    async def _start_server(self, name: str, config: dict):
        """Start an MCP server."""
        command = config["command"]
        args = config.get("args", [])
        env = config.get("env", {})

        # Start server process
        process = await asyncio.create_subprocess_exec(
            *command.split() + args,
            env={**os.environ, **env},
            stdin=asyncio.subprocess.PIPE,
            stdout=asyncio.subprocess.PIPE,
            stderr=asyncio.subprocess.PIPE
        )

        self.servers[name] = ServerProcess(
            name=name,
            process=process,
            config=config
        )

    async def _stop_server(self, name: str):
        """Stop an MCP server."""
        if name in self.servers:
            server = self.servers[name]
            server.process.terminate()
            await server.process.wait()
            del self.servers[name]

    async def _route_request(self, tool_name: str, arguments: dict) -> dict:
        """Route a tool request to the appropriate server."""
        # Find server that provides this tool
        for name, server in self.servers.items():
            if tool_name in server.tools:
                return await server.call_tool(tool_name, arguments)

        raise ValueError(f"No server provides tool: {tool_name}")

    async def _listen(self):
        """Listen for incoming requests on Unix socket."""
        server = await asyncio.start_unix_server(
            self._handle_client,
            path=str(self.socket_path)
        )

        async with server:
            await server.serve_forever()

    async def _handle_client(self, reader, writer):
        """Handle incoming client connection."""
        try:
            data = await reader.read(65536)
            request = json.loads(data.decode())

            if request["type"] == "call_tool":
                result = await self._route_request(
                    request["tool"],
                    request.get("arguments", {})
                )
                response = {"success": True, "result": result}
            elif request["type"] == "list_tools":
                tools = self._get_all_tools()
                response = {"success": True, "tools": tools}
            else:
                response = {"success": False, "error": "Unknown request type"}

            writer.write(json.dumps(response).encode())
            await writer.drain()
        except Exception as e:
            response = {"success": False, "error": str(e)}
            writer.write(json.dumps(response).encode())
            await writer.drain()
        finally:
            writer.close()
            await writer.wait_closed()

    def _get_all_tools(self) -> list[dict]:
        """Get all tools from all servers."""
        tools = []
        for name, server in self.servers.items():
            for tool in server.tools:
                tools.append({
                    "server": name,
                    "name": tool.name,
                    "description": tool.description
                })
        return tools

    def _load_config(self) -> dict:
        """Load hub configuration."""
        config_file = self.config_path / "config.yaml"
        if config_file.exists():
            import yaml
            return yaml.safe_load(config_file.read_text())
        return {}


class ServerProcess:
    """Wrapper for a managed MCP server process."""

    def __init__(self, name: str, process, config: dict):
        self.name = name
        self.process = process
        self.config = config
        self.tools: list[Tool] = []
        self.resources: list[Resource] = []

    async def initialize(self):
        """Initialize connection and discover capabilities."""
        # Send initialize request to server
        # Parse response to get tools and resources
        pass

    async def call_tool(self, name: str, arguments: dict) -> dict:
        """Call a tool on this server."""
        request = {
            "jsonrpc": "2.0",
            "id": 1,
            "method": "tools/call",
            "params": {
                "name": name,
                "arguments": arguments
            }
        }

        self.process.stdin.write(json.dumps(request).encode() + b"\n")
        await self.process.stdin.drain()

        response = await self.process.stdout.readline()
        return json.loads(response)


# CLI entry point
if __name__ == "__main__":
    import sys

    action = sys.argv[1] if len(sys.argv) > 1 else "start"

    config_path = Path.home() / ".config/daedalos/mcp-hub"
    socket_path = Path("/run/daedalos/mcp-hub.sock")

    daemon = MCPHubDaemon(config_path, socket_path)

    if action == "start":
        asyncio.run(daemon.start())
    elif action == "stop":
        asyncio.run(daemon.stop())
    elif action == "status":
        # Print status
        pass
```

================================================================================
                            REGISTRY (registry.py)
================================================================================

```python
"""Server registry - catalog of known MCP servers."""

from pathlib import Path
import yaml
from typing import Optional
from dataclasses import dataclass


@dataclass
class ServerInfo:
    name: str
    description: str
    command: str
    args: list[str]
    category: str
    tools: list[str]
    resources: list[str]
    requires_auth: bool
    source: str  # npm|github|local


class ServerRegistry:
    """Registry of known MCP servers."""

    def __init__(self, registry_path: Path):
        self.registry_path = registry_path
        self.servers: dict[str, ServerInfo] = {}
        self._load_builtin()
        self._load_installed()

    def _load_builtin(self):
        """Load built-in server definitions."""
        builtin = [
            ServerInfo(
                name="filesystem",
                description="File system operations",
                command="npx @modelcontextprotocol/server-filesystem",
                args=["/"],
                category="core",
                tools=["read_file", "write_file", "list_directory", "create_directory",
                       "move_file", "search_files", "get_file_info", "read_multiple_files"],
                resources=[],
                requires_auth=False,
                source="npm"
            ),
            ServerInfo(
                name="github",
                description="GitHub operations",
                command="npx @modelcontextprotocol/server-github",
                args=[],
                category="integrations",
                tools=["create_issue", "create_pull_request", "search_code",
                       "list_commits", "get_file_contents", "push_files"],
                resources=["repo", "issue", "pull_request"],
                requires_auth=True,
                source="npm"
            ),
            ServerInfo(
                name="memory",
                description="Persistent memory for conversations",
                command="npx @modelcontextprotocol/server-memory",
                args=[],
                category="core",
                tools=["store", "retrieve", "list", "delete"],
                resources=[],
                requires_auth=False,
                source="npm"
            ),
        ]

        for server in builtin:
            self.servers[server.name] = server

    def _load_installed(self):
        """Load user-installed servers from config."""
        installed_file = self.registry_path / "installed.yaml"
        if installed_file.exists():
            data = yaml.safe_load(installed_file.read_text())
            for name, info in data.items():
                self.servers[name] = ServerInfo(**info)

    def list(self, category: Optional[str] = None) -> list[ServerInfo]:
        """List servers, optionally filtered by category."""
        servers = list(self.servers.values())
        if category:
            servers = [s for s in servers if s.category == category]
        return servers

    def search(self, query: str) -> list[ServerInfo]:
        """Search servers by name or tool."""
        query = query.lower()
        results = []
        for server in self.servers.values():
            if query in server.name.lower():
                results.append(server)
            elif any(query in tool.lower() for tool in server.tools):
                results.append(server)
            elif query in server.description.lower():
                results.append(server)
        return results

    def get(self, name: str) -> Optional[ServerInfo]:
        """Get server by name."""
        return self.servers.get(name)

    def install(self, source: str) -> ServerInfo:
        """Install a server from source (npm, github, local)."""
        # Parse source and install
        if source.startswith("npm:"):
            return self._install_npm(source[4:])
        elif source.startswith("github:"):
            return self._install_github(source[7:])
        else:
            # Assume it's a known server name
            return self._install_known(source)

    def _install_npm(self, package: str) -> ServerInfo:
        """Install from npm."""
        import subprocess
        subprocess.run(["npm", "install", "-g", package], check=True)
        # Parse package to get server info
        # Add to installed.yaml
        pass

    def _install_github(self, repo: str) -> ServerInfo:
        """Install from GitHub."""
        # Clone repo, determine how to run
        pass

    def _install_known(self, name: str) -> ServerInfo:
        """Install a known server by name."""
        # Just enable it in config
        pass
```

================================================================================
                             ROUTER (router.py)
================================================================================

```python
"""Request router - sends requests to appropriate servers."""

import json
import socket
from pathlib import Path
from typing import Optional


class Router:
    """Route MCP requests to the hub daemon."""

    def __init__(self, socket_path: Path):
        self.socket_path = socket_path

    def _send_request(self, request: dict) -> dict:
        """Send request to hub daemon."""
        sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
        sock.connect(str(self.socket_path))

        sock.send(json.dumps(request).encode())
        response = sock.recv(65536)
        sock.close()

        return json.loads(response)

    def call_tool(self, tool_name: str, arguments: dict, server: Optional[str] = None) -> dict:
        """Call a tool, optionally on a specific server."""
        request = {
            "type": "call_tool",
            "tool": tool_name,
            "arguments": arguments
        }
        if server:
            request["server"] = server

        return self._send_request(request)

    def list_tools(self) -> list[dict]:
        """List all available tools."""
        request = {"type": "list_tools"}
        response = self._send_request(request)
        return response.get("tools", [])

    def list_resources(self) -> list[dict]:
        """List all available resources."""
        request = {"type": "list_resources"}
        response = self._send_request(request)
        return response.get("resources", [])


# CLI entry point
if __name__ == "__main__":
    import sys

    socket_path = Path("/run/daedalos/mcp-hub.sock")
    router = Router(socket_path)

    if sys.argv[1] == "call":
        tool_name = sys.argv[2]
        # Parse remaining args as key=value
        arguments = {}
        for arg in sys.argv[3:]:
            if "=" in arg:
                key, value = arg.split("=", 1)
                arguments[key.lstrip("-")] = value

        result = router.call_tool(tool_name, arguments)
        print(json.dumps(result, indent=2))
```

================================================================================
                           SUCCESS CRITERIA
================================================================================

The mcp-hub tool is complete when:

1. DAEMON
   [ ] Starts and listens on Unix socket
   [ ] Manages server lifecycle
   [ ] Routes requests to servers
   [ ] Handles multiple concurrent requests

2. REGISTRY
   [ ] Lists available servers
   [ ] Installs new servers
   [ ] Searches by name/tool
   [ ] Manages server configuration

3. CLI
   [ ] mcp-hub start/stop/status work
   [ ] mcp-hub list shows servers
   [ ] mcp-hub tools shows available tools
   [ ] mcp-hub call invokes tools
   [ ] mcp-hub config manages settings

4. INTEGRATION
   [ ] Works with OpenCode
   [ ] Works with Claude Code
   [ ] Project-specific overrides

================================================================================
