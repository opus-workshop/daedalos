name: project
version: 1.0
created: 2025-01-11

intent: |
  Agents waste massive context reading files to understand architecture.

  The project tool provides instant codebase intelligence through pre-computed
  indexes. When an agent enters a new project, `project info` gives architectural
  context in seconds, not minutes of exploration.

  The key insight: codebases don't change structure often. Pre-compute once,
  query instantly. An agent shouldn't re-discover that "src/controllers" contains
  controllers every single time - that's already in the index.

  This directly reduces token waste and lets agents focus on actual work.

constraints:
  - Index must stay current with filesystem changes (fswatch/inotify)
  - Queries return in < 100ms on indexed data
  - Works without language-specific tooling (fallback to patterns)
  - No dependencies beyond sqlite3, ripgrep, jq
  - Index size proportional to codebase size (not exploding)
  - Graceful degradation when tree-sitter unavailable
  - Works on any project type (Swift, TS, Python, Rust, Go, etc.)

interface:
  commands:
    info:
      args: "[path]"
      returns: "Architecture overview: type, patterns, entry points, key modules"
      example: "project info"

    tree:
      args: "[path] [--depth n]"
      returns: "Directory structure with descriptions and purpose"
      example: "project tree --depth 2"

    symbols:
      args: "[path] [--type function|class|type]"
      returns: "All symbols (functions, classes, types) in project"
      example: "project symbols --type class"

    deps:
      args: "<file> [--transitive]"
      returns: "What a file imports/depends on"
      example: "project deps src/auth.ts"

    dependents:
      args: "<file>"
      returns: "What imports/depends on this file"
      example: "project dependents src/utils.ts"

    hot-files:
      args: "[--since date] [-n count]"
      returns: "Most frequently modified files (via git history)"
      example: "project hot-files --since 2025-01-01"

    index:
      args: "[--full] [--watch]"
      returns: "Trigger re-indexing or start watch daemon"
      example: "project index --watch"

  exit_codes:
    0: success
    1: project not found or indexing failed
    2: configuration error
    3: query timeout

examples:
  - scenario: "Agent enters unfamiliar codebase"
    context: "Starting work on a project never seen before"
    action: "project info"
    result: |
      Instant summary:
      - Type: SwiftUI iOS App
      - Architecture: MVVM + SwiftData
      - Entry: KavaraApp.swift â†’ ContentView
      - Key modules: BusinessLogic/, DataLayer/, Presentation/
    why_it_matters: "Agent orients in seconds, not minutes of exploration"

  - scenario: "Finding where to add code"
    context: "Need to add a new feature but don't know where"
    action: "project tree --depth 2"
    result: "Annotated tree showing purpose of each directory"
    why_it_matters: "Code lands in the right place from the start"

  - scenario: "Understanding impact of changes"
    context: "About to modify a utility function"
    action: "project dependents src/utils/format.ts"
    result: "List of 12 files that import this function"
    why_it_matters: "Agent knows blast radius before making changes"

  - scenario: "Finding all implementations"
    context: "Need to understand how authentication works"
    action: "project symbols --type function | grep -i auth"
    result: "All auth-related functions across the codebase"
    why_it_matters: "Structural search faster than grepping source code"

decisions:
  - choice: "SQLite for index storage"
    why: |
      Fast indexed queries, single file, atomic transactions.
      Tables: files, symbols, dependencies, conventions, metadata.

      Content not stored in SQLite - just paths and metadata.
      Actual file content read on demand from filesystem.
    alternatives:
      - option: "JSON files per module"
        rejected_because: "Slow queries across large codebases, no atomicity"
      - option: "Embedded key-value (RocksDB)"
        rejected_because: "Extra dependency, overkill for read-heavy workload"

  - choice: "Pattern-based detection with tree-sitter enhancement"
    why: |
      Base detection uses file patterns and simple regex - works everywhere.
      Tree-sitter adds precision when available but isn't required.

      This means project tool works on any system, but is better with
      tree-sitter installed. Progressive enhancement over requirements.
    alternatives:
      - option: "Require tree-sitter"
        rejected_because: "Adds hard dependency, installation pain on some systems"
      - option: "Language server integration"
        rejected_because: "Slow startup, heavy dependencies, not always available"

  - choice: "Cache per-project by path hash"
    why: |
      Location: ~/.cache/daedalos/project/<hash>/
      Hash = sha256(absolute_path)[:16]

      Keeps caches isolated, easy to clean, no conflicts.
      Invalidation by mtime comparison - fast on modern filesystems.

  - choice: "fswatch daemon for live updates"
    why: |
      Background daemon watches for file changes, updates index incrementally.
      Debounced (100ms) to handle rapid saves.

      This means queries are always against current state, not stale.
      Daemon auto-starts when project tool runs, auto-stops when idle.

anti_patterns:
  - pattern: "Re-indexing on every query"
    why_bad: |
      Defeats the purpose. Index once, query many times.
      Only re-index when files actually change (mtime check is fast).

  - pattern: "Indexing node_modules, .git, build/"
    why_bad: |
      Explodes index size, slows everything, noise in results.
      Respect .gitignore by default. These are generated files.

  - pattern: "Blocking on index completion"
    why_bad: |
      First run should show progress, but subsequent queries shouldn't wait.
      Return partial results with "indexing..." indicator if needed.

  - pattern: "Storing file content in index"
    why_bad: |
      Index should store metadata and structure, not content.
      Content is already on disk - don't duplicate it.

  - pattern: "Language-specific queries without fallback"
    why_bad: |
      "project symbols" should work on unknown languages too, even if
      degraded (pattern matching instead of AST). Never fail completely.

connects_to:
  - component: codex
    relationship: |
      Codex provides semantic search, project provides structural intelligence.
      They complement: "find auth code" (codex) vs "what calls auth()" (project).

  - component: context
    relationship: |
      Context tool uses project to estimate token cost of files.
      "context estimate" includes project index info for accuracy.

  - component: loop
    relationship: |
      Loop can use project to scope iterations - "only touch files in src/auth/".
      Project provides the file list, loop constrains the scope.

  - component: agent
    relationship: |
      When spawning agents, project info is injected into initial context.
      Agents start oriented, not exploring blindly.

metrics:
  success_criteria:
    - "project info returns in < 200ms on indexed codebase"
    - "Index stays under 10MB for typical projects"
    - "Agents never ask 'what is this project' after using project tool"
    - "Zero false positives in architecture detection"

  failure_indicators:
    - "Agents still spending tokens exploring structure"
    - "Index frequently out of date"
    - "Queries time out on large codebases"
