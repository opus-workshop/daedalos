#!/usr/bin/env bash
# gates - Configurable approval checkpoints for Daedalos
#
# Control how much autonomy AI agents have.

set -eo pipefail

GATES_VERSION="1.0.0"

# Get the real path, following symlinks
SCRIPT_PATH="${BASH_SOURCE[0]}"
while [[ -L "$SCRIPT_PATH" ]]; do
    SCRIPT_DIR="$(cd "$(dirname "$SCRIPT_PATH")" && pwd)"
    SCRIPT_PATH="$(readlink "$SCRIPT_PATH")"
    [[ "$SCRIPT_PATH" != /* ]] && SCRIPT_PATH="$SCRIPT_DIR/$SCRIPT_PATH"
done
SCRIPT_DIR="$(cd "$(dirname "$SCRIPT_PATH")" && pwd)"
LIB_DIR="$(dirname "$SCRIPT_DIR")/lib"

export PYTHONPATH="${PYTHONPATH:-}:$LIB_DIR"

# Colors
if [[ -t 1 ]]; then
    RED='\033[0;31m'
    GREEN='\033[0;32m'
    YELLOW='\033[0;33m'
    BLUE='\033[0;34m'
    CYAN='\033[0;36m'
    BOLD='\033[1m'
    DIM='\033[2m'
    NC='\033[0m'
else
    RED='' GREEN='' YELLOW='' BLUE='' CYAN='' BOLD='' DIM='' NC=''
fi

log_error() { echo -e "${RED}error:${NC} $*" >&2; }
log_info() { echo -e "${BLUE}info:${NC} $*"; }
log_success() { echo -e "${GREEN}✓${NC} $*"; }

cmd_help() {
    cat << 'EOF'
gates - Configurable approval checkpoints for Daedalos

USAGE:
    gates <command> [args...]

COMMANDS:
    check <gate>     Check if an action is allowed through a gate
    level [LEVEL]    Get or set supervision level
    set <gate> <action>  Set a gate action
    config           Show current configuration
    history          Show gate check history
    init             Initialize config file with defaults

SUPERVISION LEVELS:
    autonomous       AI runs freely, minimal gates
    supervised       AI runs, human gets notifications
    collaborative    AI proposes, human approves major actions
    assisted         Human drives, AI suggests
    manual           AI only responds to direct commands

GATE ACTIONS:
    allow            Proceed without asking
    notify           Notify but don't block
    approve          Require explicit approval
    deny             Always deny

BUILT-IN GATES:
    file_delete      Deleting files
    file_create      Creating new files
    file_modify      Modifying existing files
    git_commit       Making git commits
    git_push         Pushing to remote
    git_force_push   Force pushing
    loop_start       Starting iteration loops
    agent_spawn      Spawning new agents
    shell_command    Running shell commands
    sensitive_file   Modifying sensitive files (secrets, env, keys)

EXAMPLES:
    gates level                    # Show current level
    gates level supervised         # Set supervision level
    gates check file_delete        # Check if file deletion allowed
    gates set git_push approve     # Require approval for git push
    gates history                  # Show recent gate checks

CONFIG FILES:
    ~/.config/daedalos/supervision.yaml     Global config
    .daedalos/supervision.yaml              Project override (more restrictive only)

EOF
}

cmd_check() {
    local gate="$1"
    local context="${2:-}"
    local source="${3:-cli}"

    if [[ -z "$gate" ]]; then
        log_error "Gate name required"
        echo "Usage: gates check <gate> [context-json] [source]"
        exit 1
    fi

    python3 << PYTHON
import sys
import json
sys.path.insert(0, "$LIB_DIR")

from checker import check_gate

context = {}
if "$context":
    try:
        context = json.loads('''$context''')
    except:
        pass

result = check_gate("$gate", context=context, source="$source")

if result.allowed:
    print(f"allowed: {result.reason}")
    sys.exit(0)
else:
    print(f"denied: {result.reason}")
    sys.exit(1)
PYTHON
}

cmd_level() {
    local new_level="${1:-}"

    if [[ -z "$new_level" ]]; then
        # Get current level
        python3 << 'PYTHON'
import sys
sys.path.insert(0, "$LIB_DIR")
from config import load_config
config = load_config()
print(config.level)
PYTHON
        return
    fi

    # Set new level
    python3 << PYTHON
import sys
sys.path.insert(0, "$LIB_DIR")
from config import load_config, save_config, SUPERVISION_LEVELS

new_level = "$new_level"
if new_level not in SUPERVISION_LEVELS:
    print(f"error: Invalid level '{new_level}'", file=sys.stderr)
    print(f"Valid levels: {', '.join(SUPERVISION_LEVELS)}", file=sys.stderr)
    sys.exit(1)

config = load_config()
config.level = new_level
# Reset gates to new level defaults
from config import DEFAULT_GATES, SupervisionConfig
config = SupervisionConfig(level=new_level, autonomy=config.autonomy)
save_config(config)
print(f"Supervision level set to: {new_level}")
PYTHON
}

cmd_set() {
    local gate="$1"
    local action="$2"

    if [[ -z "$gate" ]] || [[ -z "$action" ]]; then
        log_error "Gate and action required"
        echo "Usage: gates set <gate> <action>"
        exit 1
    fi

    python3 << PYTHON
import sys
sys.path.insert(0, "$LIB_DIR")
from config import load_config, save_config, GATE_ACTIONS

action = "$action"
if action not in GATE_ACTIONS:
    print(f"error: Invalid action '{action}'", file=sys.stderr)
    print(f"Valid actions: {', '.join(GATE_ACTIONS)}", file=sys.stderr)
    sys.exit(1)

config = load_config()
config.gates["$gate"] = action
save_config(config)
print(f"Gate '$gate' set to: {action}")
PYTHON
}

cmd_config() {
    local as_json=false

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --json) as_json=true; shift ;;
            *) shift ;;
        esac
    done

    if [[ "$as_json" == true ]]; then
        python3 << 'PYTHON'
import sys
import json
sys.path.insert(0, "$LIB_DIR")
from config import load_project_config

config = load_project_config()
print(json.dumps(config.to_dict(), indent=2))
PYTHON
    else
        python3 << 'PYTHON'
import sys
sys.path.insert(0, "$LIB_DIR")
from config import load_project_config, get_config_path

config = load_project_config()

print(f"Config file: {get_config_path()}")
print(f"Level: {config.level}")
print()
print("Gates:")
for gate, action in sorted(config.gates.items()):
    color = {"allow": "\033[32m", "notify": "\033[33m", "approve": "\033[34m", "deny": "\033[31m"}.get(action, "")
    reset = "\033[0m" if color else ""
    print(f"  {gate}: {color}{action}{reset}")

if config.overrides:
    print()
    print("Project Overrides:")
    for gate, action in sorted(config.overrides.items()):
        print(f"  {gate}: {action}")

print()
print("Autonomy Limits:")
for key, value in sorted(config.autonomy.items()):
    if key == "sensitive_paths":
        print(f"  {key}:")
        for p in value:
            print(f"    - {p}")
    else:
        print(f"  {key}: {value}")
PYTHON
    fi
}

cmd_history() {
    local gate=""
    local days=7
    local limit=20
    local as_json=false

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --gate) gate="$2"; shift 2 ;;
            --days) days="$2"; shift 2 ;;
            --limit) limit="$2"; shift 2 ;;
            --json) as_json=true; shift ;;
            *) shift ;;
        esac
    done

    python3 << PYTHON
import sys
import json
from datetime import datetime
sys.path.insert(0, "$LIB_DIR")
from checker import get_gate_history

gate = "$gate" if "$gate" else None
history = get_gate_history(gate=gate, days=$days, limit=$limit)

if $([[ "$as_json" == true ]] && echo "True" || echo "False"):
    print(json.dumps(history, indent=2))
else:
    if not history:
        print("No gate history found")
    else:
        for event in history:
            ts = datetime.fromtimestamp(event.get("timestamp", 0))
            time_str = ts.strftime("%Y-%m-%d %H:%M:%S")
            gate = event.get("gate", "?")
            result = event.get("result", {})
            allowed = "✓" if result.get("allowed") else "✗"
            action = result.get("action", "?")
            source = event.get("source", "?")

            color = "\033[32m" if result.get("allowed") else "\033[31m"
            reset = "\033[0m"

            print(f"{time_str}  {color}{allowed}{reset}  {gate:<20}  {action:<8}  {source}")
PYTHON
}

cmd_init() {
    python3 << 'PYTHON'
import sys
sys.path.insert(0, "$LIB_DIR")
from config import load_config, save_config, get_config_path

config_path = get_config_path()
if config_path.exists():
    print(f"Config already exists: {config_path}")
    print("Use 'gates level <level>' to change supervision level")
else:
    config = load_config()  # Creates defaults
    save_config(config)
    print(f"Created config: {config_path}")
    print(f"Default level: {config.level}")
PYTHON
}

main() {
    local cmd="${1:-help}"

    case "$cmd" in
        help|--help|-h)
            cmd_help
            ;;
        check)
            shift
            cmd_check "$@"
            ;;
        level)
            shift
            cmd_level "$@"
            ;;
        set)
            shift
            cmd_set "$@"
            ;;
        config)
            shift
            cmd_config "$@"
            ;;
        history)
            shift
            cmd_history "$@"
            ;;
        init)
            cmd_init
            ;;
        version|--version|-V)
            echo "gates $GATES_VERSION"
            ;;
        *)
            log_error "Unknown command: $cmd"
            echo "Run 'gates help' for usage"
            exit 1
            ;;
    esac
}

main "$@"
