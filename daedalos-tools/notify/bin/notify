#!/usr/bin/env bash
# notify - Desktop notifications for Daedalos
#
# Unified notification system that works across platforms.

set -eo pipefail

NOTIFY_VERSION="1.0.0"

# Data directories
DATA_DIR="${XDG_DATA_HOME:-$HOME/.local/share}/daedalos/notify"
CONFIG_DIR="${XDG_CONFIG_HOME:-$HOME/.config}/daedalos"

mkdir -p "$DATA_DIR"

# Colors
if [[ -t 1 ]]; then
    RED='\033[0;31m'
    GREEN='\033[0;32m'
    YELLOW='\033[0;33m'
    BLUE='\033[0;34m'
    CYAN='\033[0;36m'
    BOLD='\033[1m'
    DIM='\033[2m'
    NC='\033[0m'
else
    RED='' GREEN='' YELLOW='' BLUE='' CYAN='' MAGENTA='' BOLD='' DIM='' NC=''
fi

log_error() { echo -e "${RED}error:${NC} $*" >&2; }
log_success() { echo -e "${GREEN}‚úì${NC} $*"; }

cmd_help() {
    cat << 'EOF'
notify - Desktop notifications for Daedalos

USAGE:
    notify <message> [options]
    notify <command> [args...]

COMMANDS:
    send <msg>       Send a notification (default command)
    success <msg>    Send a success notification
    error <msg>      Send an error notification
    warn <msg>       Send a warning notification
    progress <msg>   Send a progress notification
    watch <cmd>      Run command and notify on completion
    history          Show notification history
    clear            Clear notification history
    test             Test notification system

OPTIONS:
    --title, -t      Notification title (default: "Daedalos")
    --icon, -i       Icon name or path
    --sound, -s      Play sound (default: true)
    --urgent, -u     Mark as urgent
    --timeout N      Auto-dismiss after N seconds
    --action CMD     Command to run when clicked

EXAMPLES:
    notify "Build complete"                    # Simple notification
    notify success "Tests passed"              # Success notification
    notify error "Build failed" --urgent       # Urgent error
    notify watch "npm run build"               # Notify when done
    notify --title "Deploy" "Starting..."      # Custom title

PLATFORM SUPPORT:
    macOS:   Uses osascript/terminal-notifier
    Linux:   Uses notify-send (libnotify)
    WSL:     Uses powershell notifications

INTEGRATION:
    Daedalos tools use notify for:
    - Loop completion/failure
    - Agent task completion
    - Gate approval requests
    - Long-running command completion

EOF
}

# Detect notification backend
detect_backend() {
    if [[ "$OSTYPE" == "darwin"* ]]; then
        if command -v terminal-notifier &>/dev/null; then
            echo "terminal-notifier"
        else
            echo "osascript"
        fi
    elif [[ -n "$WSL_DISTRO_NAME" ]]; then
        echo "wsl"
    elif command -v notify-send &>/dev/null; then
        echo "notify-send"
    elif command -v kdialog &>/dev/null; then
        echo "kdialog"
    else
        echo "echo"
    fi
}

# Send notification using detected backend
send_notification() {
    local title="${1:-Daedalos}"
    local message="$2"
    local icon="${3:-}"
    local urgency="${4:-normal}"
    local timeout="${5:-}"
    local sound="${6:-true}"
    local action="${7:-}"

    local backend=$(detect_backend)

    case "$backend" in
        terminal-notifier)
            local args=(-title "$title" -message "$message" -group "daedalos")
            [[ -n "$icon" ]] && args+=(-appIcon "$icon")
            [[ "$urgency" == "critical" ]] && args+=(-sound "Basso")
            [[ "$sound" == "true" ]] && args+=(-sound "default")
            [[ -n "$action" ]] && args+=(-execute "$action")
            terminal-notifier "${args[@]}"
            ;;

        osascript)
            local script="display notification \"$message\" with title \"$title\""
            [[ "$sound" == "true" ]] && script="$script sound name \"default\""
            osascript -e "$script"
            ;;

        notify-send)
            local args=("$title" "$message")
            [[ -n "$icon" ]] && args+=(--icon "$icon")
            [[ "$urgency" == "critical" ]] && args+=(--urgency critical)
            [[ -n "$timeout" ]] && args+=(--expire-time "$((timeout * 1000))")
            notify-send "${args[@]}"
            ;;

        kdialog)
            kdialog --passivepopup "$message" "${timeout:-5}" --title "$title"
            ;;

        wsl)
            powershell.exe -Command "[Windows.UI.Notifications.ToastNotificationManager, Windows.UI.Notifications, ContentType = WindowsRuntime] | Out-Null; \$template = [Windows.UI.Notifications.ToastNotificationManager]::GetTemplateContent([Windows.UI.Notifications.ToastTemplateType]::ToastText02); \$template.GetElementsByTagName('text')[0].AppendChild(\$template.CreateTextNode('$title')) | Out-Null; \$template.GetElementsByTagName('text')[1].AppendChild(\$template.CreateTextNode('$message')) | Out-Null; [Windows.UI.Notifications.ToastNotificationManager]::CreateToastNotifier('Daedalos').Show([Windows.UI.Notifications.ToastNotification]::new(\$template))" 2>/dev/null || echo "[$title] $message"
            ;;

        echo)
            echo "[$title] $message"
            ;;
    esac

    # Log notification
    log_notification "$title" "$message" "$urgency"
}

# Log notification to history
log_notification() {
    local title="$1"
    local message="$2"
    local urgency="${3:-normal}"
    local timestamp=$(date +%s)

    echo "$timestamp|$title|$message|$urgency" >> "$DATA_DIR/history"
}

cmd_send() {
    local message=""
    local title="Daedalos"
    local icon=""
    local urgency="normal"
    local timeout=""
    local sound="true"
    local action=""

    while [[ $# -gt 0 ]]; do
        case "$1" in
            -t|--title) title="$2"; shift 2 ;;
            -i|--icon) icon="$2"; shift 2 ;;
            -u|--urgent) urgency="critical"; shift ;;
            --timeout) timeout="$2"; shift 2 ;;
            --sound) sound="$2"; shift 2 ;;
            --action) action="$2"; shift 2 ;;
            --no-sound) sound="false"; shift ;;
            -*) shift ;;
            *)
                if [[ -z "$message" ]]; then
                    message="$1"
                fi
                shift
                ;;
        esac
    done

    if [[ -z "$message" ]]; then
        log_error "Message required"
        exit 1
    fi

    send_notification "$title" "$message" "$icon" "$urgency" "$timeout" "$sound" "$action"
    log_success "Notification sent"
}

cmd_success() {
    local message="$1"
    shift || true
    send_notification "‚úì Success" "$message" "" "normal" "" "true" "$@"
    log_success "Success notification sent"
}

cmd_error() {
    local message="$1"
    local urgent=""
    shift || true

    while [[ $# -gt 0 ]]; do
        case "$1" in
            -u|--urgent) urgent="critical"; shift ;;
            *) shift ;;
        esac
    done

    send_notification "‚úó Error" "$message" "" "${urgent:-normal}" "" "true"
    log_success "Error notification sent"
}

cmd_warn() {
    local message="$1"
    send_notification "‚ö† Warning" "$message" "" "normal" "" "true"
    log_success "Warning notification sent"
}

cmd_progress() {
    local message="$1"
    send_notification "‚è≥ In Progress" "$message" "" "low" "" "false"
    log_success "Progress notification sent"
}

cmd_watch() {
    local cmd="$*"

    if [[ -z "$cmd" ]]; then
        log_error "Command required"
        echo "Usage: notify watch <command>"
        exit 1
    fi

    echo -e "${CYAN}Running:${NC} $cmd"
    local start_time=$(date +%s)

    # Run command
    local exit_code=0
    eval "$cmd" || exit_code=$?

    local end_time=$(date +%s)
    local duration=$((end_time - start_time))
    local duration_str="${duration}s"
    [[ $duration -gt 60 ]] && duration_str="$((duration / 60))m $((duration % 60))s"

    if [[ $exit_code -eq 0 ]]; then
        send_notification "‚úì Complete" "Command finished in $duration_str" "" "normal" "" "true"
        log_success "Command completed successfully"
    else
        send_notification "‚úó Failed" "Command failed after $duration_str (exit: $exit_code)" "" "critical" "" "true"
        log_error "Command failed with exit code $exit_code"
    fi

    return $exit_code
}

cmd_history() {
    local limit="${1:-20}"
    local history_file="$DATA_DIR/history"

    if [[ ! -f "$history_file" ]]; then
        echo "No notification history"
        return
    fi

    echo -e "${BOLD}Notification History${NC}"
    echo ""

    tail -n "$limit" "$history_file" | while IFS='|' read -r timestamp title message urgency; do
        local date_str=$(date -r "$timestamp" "+%Y-%m-%d %H:%M:%S" 2>/dev/null || date -d "@$timestamp" "+%Y-%m-%d %H:%M:%S" 2>/dev/null)
        local urgency_icon=""
        [[ "$urgency" == "critical" ]] && urgency_icon=" üî¥"

        echo -e "${DIM}$date_str${NC}$urgency_icon"
        echo -e "  ${BOLD}$title${NC}: $message"
        echo ""
    done
}

cmd_clear() {
    rm -f "$DATA_DIR/history"
    log_success "Notification history cleared"
}

cmd_test() {
    local backend=$(detect_backend)
    echo -e "${BOLD}Testing notification system${NC}"
    echo -e "  ${CYAN}Backend:${NC} $backend"
    echo ""

    send_notification "Daedalos Test" "If you see this, notifications are working!" "" "normal" "" "true"

    echo ""
    log_success "Test notification sent"
    echo "Check if you received the notification"
}

main() {
    local cmd="${1:-help}"

    case "$cmd" in
        help|--help|-h)
            cmd_help
            ;;
        send|s)
            shift
            cmd_send "$@"
            ;;
        success)
            shift
            cmd_success "$@"
            ;;
        error|err)
            shift
            cmd_error "$@"
            ;;
        warn|warning)
            shift
            cmd_warn "$@"
            ;;
        progress)
            shift
            cmd_progress "$@"
            ;;
        watch|w)
            shift
            cmd_watch "$@"
            ;;
        history)
            shift
            cmd_history "$@"
            ;;
        clear)
            cmd_clear
            ;;
        test)
            cmd_test
            ;;
        version|--version|-V)
            echo "notify $NOTIFY_VERSION"
            ;;
        -*)
            # Treat as send with options
            cmd_send "$@"
            ;;
        *)
            # Default: treat as message for send
            cmd_send "$@"
            ;;
    esac
}

main "$@"
