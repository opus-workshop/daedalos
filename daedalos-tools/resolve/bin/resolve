#!/usr/bin/env bash
#
# resolve - Resolve uncertainty through context gathering
#
# Instead of asking the user, gather context from specs, codebase,
# and research to make confident decisions.
#
# Two phases:
#   1. Intent: Clarify what problem we're actually solving
#   2. Confidence: Gather context to make implementation decisions
#
# Usage:
#   resolve "<question or task>"
#   resolve --intent "<question>"    # Intent analysis only
#   resolve --gather "<question>"    # Context gathering only
#   resolve --log "<decision>"       # Log a decision to DECISIONS.md
#

set -eo pipefail

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
BOLD='\033[1m'
DIM='\033[2m'
NC='\033[0m'

# Paths
DECISIONS_FILE=".claude/DECISIONS.md"
DATA_DIR="${XDG_DATA_HOME:-$HOME/.local/share}/daedalos/resolve"
mkdir -p "$DATA_DIR"

usage() {
    cat << 'EOF'
resolve - Resolve uncertainty through context gathering

USAGE:
    resolve "<question or task>"
    resolve --intent "<question>"      Intent analysis only
    resolve --gather "<question>"      Context gathering only
    resolve --log "<decision>"         Log decision to DECISIONS.md
    resolve --json                     Output as JSON

EXAMPLES:
    resolve "should timezone be user-level or slot-level?"
    resolve "how should we handle authentication?"
    resolve --log "Chose JWT for auth because API-first"

The tool gathers context from:
  - Specs (spec query)
  - Codebase patterns (codex search)
  - Project info (project info)
  - Decision history (DECISIONS.md)

And returns:
  - Intent analysis (surface vs root problem)
  - Gathered context from each source
  - Confidence level (high/medium/low)
  - Recommended decision or suggested questions
EOF
}

# Check if a tool exists
has_tool() {
    command -v "$1" &>/dev/null
}

# Run a tool and capture output, with timeout
run_tool() {
    local tool="$1"
    shift
    if has_tool "$tool"; then
        timeout 10 "$tool" "$@" 2>/dev/null || echo ""
    else
        echo ""
    fi
}

# Analyze intent - try to identify surface vs root problem
analyze_intent() {
    local question="$1"

    echo -e "${BOLD}INTENT ANALYSIS${NC}"
    echo -e "${DIM}────────────────${NC}"
    echo ""

    # Surface question
    echo -e "${CYAN}Surface:${NC} $question"

    # Try to detect question type
    local question_type="unknown"
    local intent_clear="unclear"

    # Implementation questions (should be resolved, not asked)
    if [[ "$question" =~ ^(should|how|which|what).*(approach|method|way|implement|handle|use) ]]; then
        question_type="implementation"
        intent_clear="likely_clear"
        echo -e "${CYAN}Type:${NC} Implementation decision"
        echo -e "${CYAN}Intent:${NC} ${GREEN}Likely clear${NC} - this is a 'how' question, not 'what'"
        echo ""
        echo -e "${DIM}This question can likely be resolved through context gathering.${NC}"
        echo -e "${DIM}If context is insufficient, the root problem may need clarification.${NC}"

    # Goal/outcome questions (may need clarification)
    elif [[ "$question" =~ ^(what|why).*(goal|want|need|trying|purpose|outcome) ]]; then
        question_type="intent"
        intent_clear="unclear"
        echo -e "${CYAN}Type:${NC} Intent/goal question"
        echo -e "${CYAN}Intent:${NC} ${YELLOW}May need clarification${NC}"
        echo ""
        echo -e "${DIM}Consider asking a targeted question about the desired outcome.${NC}"

    # Feature/task descriptions
    elif [[ "$question" =~ (build|create|add|implement|make) ]]; then
        question_type="task"
        intent_clear="needs_detail"
        echo -e "${CYAN}Type:${NC} Task/feature request"
        echo -e "${CYAN}Intent:${NC} ${YELLOW}May need details${NC}"
        echo ""
        echo -e "${DIM}Consider: audience, priority, scope before implementation.${NC}"

    else
        echo -e "${CYAN}Type:${NC} General question"
        echo -e "${CYAN}Intent:${NC} ${YELLOW}Analyze further${NC}"
    fi

    echo ""

    # Return type for JSON
    echo "$question_type:$intent_clear"
}

# Gather context from various sources
gather_context() {
    local question="$1"
    local json_mode="$2"

    if [[ "$json_mode" != "true" ]]; then
        echo -e "${BOLD}CONTEXT GATHERING${NC}"
        echo -e "${DIM}──────────────────${NC}"
        echo ""
    fi

    local found_context=""
    local confidence="low"
    local sources_checked=0
    local sources_with_results=0

    # 1. Check specs
    if [[ "$json_mode" != "true" ]]; then
        echo -e "${CYAN}Checking specs...${NC}"
    fi
    local spec_result=""
    if has_tool spec; then
        # Extract key terms for spec query
        local keywords=$(echo "$question" | tr '[:upper:]' '[:lower:]' | tr -cs '[:alnum:]' ' ')
        spec_result=$(run_tool spec query "$keywords" 2>/dev/null | head -50)
        ((sources_checked++))
        if [[ -n "$spec_result" && "$spec_result" != *"No matches"* && "$spec_result" != *"Error"* ]]; then
            ((sources_with_results++))
            if [[ "$json_mode" != "true" ]]; then
                echo -e "${GREEN}Found spec context:${NC}"
                echo "$spec_result" | head -20 | sed 's/^/  /'
                echo ""
            fi
            found_context+="spec:$spec_result\n"
        else
            if [[ "$json_mode" != "true" ]]; then
                echo -e "${DIM}  No relevant specs found${NC}"
                echo ""
            fi
        fi
    fi

    # 2. Check codebase patterns
    if [[ "$json_mode" != "true" ]]; then
        echo -e "${CYAN}Checking codebase patterns...${NC}"
    fi
    local codex_result=""
    if has_tool codex; then
        codex_result=$(run_tool codex search "$question" --limit 5 2>/dev/null | head -30)
        ((sources_checked++))
        if [[ -n "$codex_result" && "$codex_result" != *"No results"* && "$codex_result" != *"Error"* ]]; then
            ((sources_with_results++))
            if [[ "$json_mode" != "true" ]]; then
                echo -e "${GREEN}Found codebase patterns:${NC}"
                echo "$codex_result" | head -15 | sed 's/^/  /'
                echo ""
            fi
            found_context+="codex:$codex_result\n"
        else
            if [[ "$json_mode" != "true" ]]; then
                echo -e "${DIM}  No relevant patterns found${NC}"
                echo ""
            fi
        fi
    fi

    # 3. Check project conventions
    if [[ "$json_mode" != "true" ]]; then
        echo -e "${CYAN}Checking project conventions...${NC}"
    fi
    local project_result=""
    if has_tool project; then
        project_result=$(run_tool project summary 2>/dev/null | head -30)
        ((sources_checked++))
        if [[ -n "$project_result" && "$project_result" != *"Error"* ]]; then
            ((sources_with_results++))
            if [[ "$json_mode" != "true" ]]; then
                echo -e "${GREEN}Project context:${NC}"
                echo "$project_result" | head -10 | sed 's/^/  /'
                echo ""
            fi
            found_context+="project:$project_result\n"
        else
            if [[ "$json_mode" != "true" ]]; then
                echo -e "${DIM}  No project info available${NC}"
                echo ""
            fi
        fi
    fi

    # 4. Check decision history
    if [[ "$json_mode" != "true" ]]; then
        echo -e "${CYAN}Checking decision history...${NC}"
    fi
    local decisions_result=""
    if [[ -f "$DECISIONS_FILE" ]]; then
        # Search for relevant past decisions
        decisions_result=$(grep -i -A3 -B1 "$(echo "$question" | cut -d' ' -f1-3)" "$DECISIONS_FILE" 2>/dev/null | head -20 || echo "")
        ((sources_checked++))
        if [[ -n "$decisions_result" ]]; then
            ((sources_with_results++))
            if [[ "$json_mode" != "true" ]]; then
                echo -e "${GREEN}Found past decisions:${NC}"
                echo "$decisions_result" | sed 's/^/  /'
                echo ""
            fi
            found_context+="decisions:$decisions_result\n"
        else
            if [[ "$json_mode" != "true" ]]; then
                echo -e "${DIM}  No relevant past decisions${NC}"
                echo ""
            fi
        fi
    else
        if [[ "$json_mode" != "true" ]]; then
            echo -e "${DIM}  No DECISIONS.md file${NC}"
            echo ""
        fi
    fi

    # Calculate confidence
    if [[ $sources_with_results -ge 3 ]]; then
        confidence="high"
    elif [[ $sources_with_results -ge 2 ]]; then
        confidence="medium"
    elif [[ $sources_with_results -ge 1 ]]; then
        confidence="low"
    else
        confidence="none"
    fi

    if [[ "$json_mode" != "true" ]]; then
        echo -e "${BOLD}CONFIDENCE: ${NC}"
        case "$confidence" in
            high)   echo -e "${GREEN}HIGH${NC} - Multiple consistent sources" ;;
            medium) echo -e "${YELLOW}MEDIUM${NC} - Some context found, may need inference" ;;
            low)    echo -e "${YELLOW}LOW${NC} - Limited context, proceed with stated assumptions" ;;
            none)   echo -e "${RED}NONE${NC} - No context found, may need to ask" ;;
        esac
        echo ""
        echo -e "${DIM}Sources checked: $sources_checked, with results: $sources_with_results${NC}"
    fi

    # Return for processing
    echo "confidence:$confidence"
    echo "sources_checked:$sources_checked"
    echo "sources_with_results:$sources_with_results"
}

# Log a decision to DECISIONS.md
log_decision() {
    local decision="$1"
    local reasoning="${2:-}"
    local date=$(date +%Y-%m-%d)
    local time=$(date +%H:%M)

    # Create DECISIONS.md if it doesn't exist
    mkdir -p "$(dirname "$DECISIONS_FILE")"
    if [[ ! -f "$DECISIONS_FILE" ]]; then
        cat > "$DECISIONS_FILE" << 'EOF'
# Decisions

This file tracks implementation decisions for future reference.
Created and maintained by the `resolve` tool.

---

EOF
    fi

    # Append decision
    cat >> "$DECISIONS_FILE" << EOF

## $date $time

**Decision:** $decision

**Reasoning:** ${reasoning:-Not specified}

**Resolved by:** resolve tool

---
EOF

    echo -e "${GREEN}Decision logged to $DECISIONS_FILE${NC}"
}

# Full resolve flow
resolve_full() {
    local question="$1"
    local json_mode="$2"

    if [[ "$json_mode" == "true" ]]; then
        # JSON output mode
        local intent_result=$(analyze_intent "$question" 2>/dev/null | tail -1)
        local question_type=$(echo "$intent_result" | cut -d: -f1)
        local intent_clear=$(echo "$intent_result" | cut -d: -f2)

        # Gather context silently
        local gather_result=$(gather_context "$question" "true" 2>/dev/null)
        local confidence=$(echo "$gather_result" | grep "^confidence:" | cut -d: -f2)
        local sources_checked=$(echo "$gather_result" | grep "^sources_checked:" | cut -d: -f2)
        local sources_with_results=$(echo "$gather_result" | grep "^sources_with_results:" | cut -d: -f2)

        cat << EOF
{
  "question": $(echo "$question" | jq -R .),
  "intent": {
    "type": "$question_type",
    "clarity": "$intent_clear"
  },
  "context": {
    "sources_checked": $sources_checked,
    "sources_with_results": $sources_with_results
  },
  "confidence": "$confidence",
  "recommendation": $(
    if [[ "$confidence" == "high" || "$confidence" == "medium" ]]; then
      echo '"proceed_with_context"'
    elif [[ "$intent_clear" == "unclear" ]]; then
      echo '"clarify_intent"'
    else
      echo '"gather_more_context"'
    fi
  )
}
EOF
    else
        # Human-readable output
        echo ""
        echo -e "${BOLD}╔══════════════════════════════════════════════════════════════╗${NC}"
        echo -e "${BOLD}║                        RESOLVE                                ║${NC}"
        echo -e "${BOLD}╚══════════════════════════════════════════════════════════════╝${NC}"
        echo ""
        echo -e "${BOLD}Question:${NC} $question"
        echo ""
        echo -e "${DIM}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
        echo ""

        # Intent phase (filter out the return value line)
        analyze_intent "$question" | grep -v "^[a-z_]*:[a-z_]*$"

        echo ""
        echo -e "${DIM}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
        echo ""

        # Context gathering phase
        gather_context "$question" "false" | grep -v "^confidence:\|^sources"

        echo ""
        echo -e "${DIM}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
        echo ""
        echo -e "${BOLD}RECOMMENDATION${NC}"
        echo -e "${DIM}───────────────${NC}"
        echo ""
        echo -e "Based on gathered context, proceed with implementation."
        echo -e "If context is insufficient, consider asking a ${CYAN}targeted${NC} question"
        echo -e "about ${CYAN}intent${NC} (what outcome is desired), not implementation details."
        echo ""
    fi
}

# Main
main() {
    local mode="full"
    local question=""
    local json_mode="false"

    while [[ $# -gt 0 ]]; do
        case "$1" in
            -h|--help)
                usage
                exit 0
                ;;
            --intent)
                mode="intent"
                shift
                question="$1"
                shift
                ;;
            --gather)
                mode="gather"
                shift
                question="$1"
                shift
                ;;
            --log)
                mode="log"
                shift
                question="$1"
                shift
                ;;
            --json)
                json_mode="true"
                shift
                ;;
            *)
                question="$1"
                shift
                ;;
        esac
    done

    if [[ -z "$question" ]]; then
        usage
        exit 1
    fi

    case "$mode" in
        intent)
            analyze_intent "$question"
            ;;
        gather)
            gather_context "$question" "$json_mode"
            ;;
        log)
            log_decision "$question" "${2:-}"
            ;;
        full)
            resolve_full "$question" "$json_mode"
            ;;
    esac
}

main "$@"
