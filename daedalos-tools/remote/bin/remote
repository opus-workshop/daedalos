#!/usr/bin/env bash
# remote - SSH and remote development for Daedalos
#
# Manage SSH connections and remote development environments.

set -eo pipefail

REMOTE_VERSION="1.0.0"

DATA_DIR="${XDG_DATA_HOME:-$HOME/.local/share}/daedalos/remote"
CONFIG_DIR="${XDG_CONFIG_HOME:-$HOME/.config}/daedalos/remote"
HOSTS_FILE="$CONFIG_DIR/hosts.json"

mkdir -p "$DATA_DIR" "$CONFIG_DIR"

# Colors
if [[ -t 1 ]]; then
    RED='\033[0;31m'
    GREEN='\033[0;32m'
    YELLOW='\033[0;33m'
    BLUE='\033[0;34m'
    CYAN='\033[0;36m'
    BOLD='\033[1m'
    DIM='\033[2m'
    NC='\033[0m'
else
    RED='' GREEN='' YELLOW='' BLUE='' CYAN='' BOLD='' DIM='' NC=''
fi

log_error() { echo -e "${RED}error:${NC} $*" >&2; }
log_success() { echo -e "${GREEN}✓${NC} $*"; }
log_info() { echo -e "${BLUE}info:${NC} $*"; }
log_warn() { echo -e "${YELLOW}!${NC} $*"; }

cmd_help() {
    cat << 'EOF'
remote - SSH and remote development for Daedalos

USAGE:
    remote <command> [args...]

COMMANDS:
    connect <HOST>       Connect to a remote host
    add <NAME>           Add a new remote host
    remove <NAME>        Remove a remote host
    list                 List configured hosts
    edit <NAME>          Edit host configuration
    sync <HOST> [PATH]   Sync files to/from remote
    tunnel <HOST>        Create SSH tunnel
    exec <HOST> <CMD>    Execute command on remote
    copy-id <HOST>       Copy SSH key to remote
    status               Show status of all hosts

SYNC OPTIONS:
    --to                 Sync local → remote (default)
    --from               Sync remote → local
    --exclude PATTERN    Exclude files matching pattern
    --dry-run            Show what would be synced

TUNNEL OPTIONS:
    --local PORT         Local port to forward
    --remote PORT        Remote port to connect to
    --reverse            Reverse tunnel (remote → local)

DEV COMMANDS:
    remote dev <HOST>    Start remote dev session
    remote agent <HOST>  Run Claude agent on remote
    remote shell <HOST>  Interactive shell with tools

EXAMPLES:
    remote add prod                          # Add new host interactively
    remote connect prod                      # SSH to 'prod'
    remote sync prod .                       # Sync current dir to remote
    remote sync prod --from /var/log ./logs  # Sync logs from remote
    remote tunnel prod --local 3000 --remote 3000
    remote exec prod "docker ps"             # Run command
    remote dev prod                          # Start dev session

CONFIGURATION:
    Hosts are stored in: ~/.config/daedalos/remote/hosts.json

    Host format:
    {
        "name": "prod",
        "host": "192.168.1.100",
        "user": "admin",
        "port": 22,
        "key": "~/.ssh/id_rsa",
        "path": "/home/admin/projects"
    }

INTEGRATION:
    - env: Remote sessions inherit project environment
    - session: Save/restore remote sessions
    - journal: Logs remote operations

EOF
}

# Initialize hosts file
init_hosts() {
    if [[ ! -f "$HOSTS_FILE" ]]; then
        echo "[]" > "$HOSTS_FILE"
    fi
}

# Get host by name
get_host() {
    local name="$1"
    init_hosts
    python3 -c "
import json
with open('$HOSTS_FILE') as f:
    hosts = json.load(f)
for h in hosts:
    if h.get('name') == '$name':
        print(json.dumps(h))
        break
" 2>/dev/null
}

# List all hosts
list_hosts() {
    init_hosts
    python3 -c "
import json
with open('$HOSTS_FILE') as f:
    hosts = json.load(f)
for h in hosts:
    print(h.get('name', 'unnamed'))
" 2>/dev/null
}

# Add a host
add_host() {
    local name="$1"
    local host="$2"
    local user="$3"
    local port="${4:-22}"
    local key="${5:-}"
    local path="${6:-}"

    init_hosts

    python3 << EOF
import json
with open('$HOSTS_FILE', 'r') as f:
    hosts = json.load(f)

# Remove existing with same name
hosts = [h for h in hosts if h.get('name') != '$name']

hosts.append({
    'name': '$name',
    'host': '$host',
    'user': '$user',
    'port': $port,
    'key': '$key' if '$key' else None,
    'path': '$path' if '$path' else None
})

with open('$HOSTS_FILE', 'w') as f:
    json.dump(hosts, f, indent=2)
EOF
}

# Remove a host
remove_host() {
    local name="$1"
    init_hosts

    python3 << EOF
import json
with open('$HOSTS_FILE', 'r') as f:
    hosts = json.load(f)

hosts = [h for h in hosts if h.get('name') != '$name']

with open('$HOSTS_FILE', 'w') as f:
    json.dump(hosts, f, indent=2)
EOF
}

# Build SSH command for host
build_ssh_cmd() {
    local host_json="$1"
    local extra_args="${2:-}"

    local host=$(echo "$host_json" | python3 -c "import json,sys; h=json.load(sys.stdin); print(h.get('host',''))")
    local user=$(echo "$host_json" | python3 -c "import json,sys; h=json.load(sys.stdin); print(h.get('user',''))")
    local port=$(echo "$host_json" | python3 -c "import json,sys; h=json.load(sys.stdin); print(h.get('port',22))")
    local key=$(echo "$host_json" | python3 -c "import json,sys; h=json.load(sys.stdin); print(h.get('key','') or '')")

    local cmd="ssh"
    [[ -n "$key" ]] && cmd="$cmd -i $key"
    [[ "$port" != "22" ]] && cmd="$cmd -p $port"
    [[ -n "$extra_args" ]] && cmd="$cmd $extra_args"
    cmd="$cmd ${user}@${host}"

    echo "$cmd"
}

cmd_connect() {
    local name="$1"
    shift || true

    if [[ -z "$name" ]]; then
        log_error "Host name required"
        echo "Usage: remote connect <HOST>"
        echo "Run 'remote list' to see configured hosts"
        exit 1
    fi

    local host_json=$(get_host "$name")

    if [[ -z "$host_json" ]]; then
        # Try direct SSH if not in config
        log_info "Host not in config, connecting directly..."
        ssh "$name" "$@"
        return
    fi

    local ssh_cmd=$(build_ssh_cmd "$host_json")

    log_info "Connecting to $name..."
    $ssh_cmd "$@"

    # Log to journal
    if command -v journal &>/dev/null; then
        journal log "Connected to remote: $name" "remote" "remote_connect" 2>/dev/null || true
    fi
}

cmd_add() {
    local name="$1"

    if [[ -z "$name" ]]; then
        log_error "Host name required"
        echo "Usage: remote add <NAME>"
        exit 1
    fi

    echo -e "${BOLD}Add Remote Host: $name${NC}"
    echo ""

    # Interactive prompts
    read -p "Hostname or IP: " host
    read -p "Username: " user
    read -p "Port [22]: " port
    port="${port:-22}"
    read -p "SSH key path (optional): " key
    read -p "Default remote path (optional): " path

    add_host "$name" "$host" "$user" "$port" "$key" "$path"

    log_success "Host added: $name"
    echo ""
    echo "Connect with: remote connect $name"
}

cmd_remove() {
    local name="$1"

    if [[ -z "$name" ]]; then
        log_error "Host name required"
        exit 1
    fi

    remove_host "$name"
    log_success "Host removed: $name"
}

cmd_list() {
    init_hosts

    echo -e "${BOLD}Remote Hosts${NC}"
    echo ""

    local hosts=$(python3 -c "
import json
with open('$HOSTS_FILE') as f:
    hosts = json.load(f)
for h in hosts:
    print(f\"{h.get('name','unnamed')}|{h.get('user','')}@{h.get('host','')}:{h.get('port',22)}|{h.get('path','')}\")
" 2>/dev/null)

    if [[ -z "$hosts" ]]; then
        echo "No hosts configured"
        echo ""
        echo "Add one with: remote add <name>"
        return
    fi

    echo "$hosts" | while IFS='|' read -r name addr path; do
        echo -e "  ${GREEN}$name${NC}"
        echo -e "    ${DIM}Address:${NC} $addr"
        [[ -n "$path" ]] && echo -e "    ${DIM}Path:${NC} $path"
        echo ""
    done
}

cmd_edit() {
    local name="$1"

    if [[ -z "$name" ]]; then
        ${EDITOR:-vim} "$HOSTS_FILE"
        return
    fi

    # Edit specific host
    log_info "Editing host: $name"
    ${EDITOR:-vim} "$HOSTS_FILE"
}

cmd_sync() {
    local name="$1"
    shift || true

    local direction="to"
    local local_path="."
    local remote_path=""
    local excludes=()
    local dry_run=false

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --to) direction="to"; shift ;;
            --from) direction="from"; shift ;;
            --exclude) excludes+=("--exclude" "$2"); shift 2 ;;
            --dry-run) dry_run=true; shift ;;
            -*) shift ;;
            *)
                if [[ -z "$local_path" ]] || [[ "$local_path" == "." ]]; then
                    local_path="$1"
                else
                    remote_path="$1"
                fi
                shift
                ;;
        esac
    done

    if [[ -z "$name" ]]; then
        log_error "Host name required"
        exit 1
    fi

    local host_json=$(get_host "$name")

    if [[ -z "$host_json" ]]; then
        log_error "Host not found: $name"
        exit 1
    fi

    local host=$(echo "$host_json" | python3 -c "import json,sys; h=json.load(sys.stdin); print(h.get('host',''))")
    local user=$(echo "$host_json" | python3 -c "import json,sys; h=json.load(sys.stdin); print(h.get('user',''))")
    local port=$(echo "$host_json" | python3 -c "import json,sys; h=json.load(sys.stdin); print(h.get('port',22))")
    local key=$(echo "$host_json" | python3 -c "import json,sys; h=json.load(sys.stdin); print(h.get('key','') or '')")
    local default_path=$(echo "$host_json" | python3 -c "import json,sys; h=json.load(sys.stdin); print(h.get('path','') or '')")

    remote_path="${remote_path:-$default_path}"
    [[ -z "$remote_path" ]] && remote_path="~/"

    local rsync_opts=("-avz" "--progress")
    [[ -n "$key" ]] && rsync_opts+=("-e" "ssh -i $key -p $port")
    [[ "$dry_run" == "true" ]] && rsync_opts+=("--dry-run")
    rsync_opts+=("${excludes[@]}")

    if [[ "$direction" == "to" ]]; then
        log_info "Syncing $local_path → ${user}@${host}:${remote_path}"
        rsync "${rsync_opts[@]}" "$local_path" "${user}@${host}:${remote_path}"
    else
        log_info "Syncing ${user}@${host}:${remote_path} → $local_path"
        rsync "${rsync_opts[@]}" "${user}@${host}:${remote_path}" "$local_path"
    fi

    log_success "Sync complete"
}

cmd_tunnel() {
    local name="$1"
    shift || true

    local local_port=""
    local remote_port=""
    local reverse=false
    local background=false

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --local|-L) local_port="$2"; shift 2 ;;
            --remote|-R) remote_port="$2"; shift 2 ;;
            --reverse) reverse=true; shift ;;
            --background|-b) background=true; shift ;;
            *) shift ;;
        esac
    done

    if [[ -z "$name" ]]; then
        log_error "Host name required"
        exit 1
    fi

    local host_json=$(get_host "$name")

    if [[ -z "$host_json" ]]; then
        log_error "Host not found: $name"
        exit 1
    fi

    local host=$(echo "$host_json" | python3 -c "import json,sys; h=json.load(sys.stdin); print(h.get('host',''))")
    local user=$(echo "$host_json" | python3 -c "import json,sys; h=json.load(sys.stdin); print(h.get('user',''))")
    local port=$(echo "$host_json" | python3 -c "import json,sys; h=json.load(sys.stdin); print(h.get('port',22))")
    local key=$(echo "$host_json" | python3 -c "import json,sys; h=json.load(sys.stdin); print(h.get('key','') or '')")

    if [[ -z "$local_port" ]] || [[ -z "$remote_port" ]]; then
        log_error "Both --local and --remote ports required"
        echo "Example: remote tunnel prod --local 3000 --remote 3000"
        exit 1
    fi

    local ssh_opts=()
    [[ -n "$key" ]] && ssh_opts+=("-i" "$key")
    [[ "$port" != "22" ]] && ssh_opts+=("-p" "$port")
    [[ "$background" == "true" ]] && ssh_opts+=("-f" "-N")

    if [[ "$reverse" == "true" ]]; then
        log_info "Creating reverse tunnel: remote:$remote_port → local:$local_port"
        ssh "${ssh_opts[@]}" -R "${remote_port}:localhost:${local_port}" "${user}@${host}"
    else
        log_info "Creating tunnel: local:$local_port → remote:$remote_port"
        ssh "${ssh_opts[@]}" -L "${local_port}:localhost:${remote_port}" "${user}@${host}"
    fi
}

cmd_exec() {
    local name="$1"
    shift || true

    if [[ -z "$name" ]] || [[ $# -eq 0 ]]; then
        log_error "Host name and command required"
        echo "Usage: remote exec <HOST> <COMMAND>"
        exit 1
    fi

    local host_json=$(get_host "$name")

    if [[ -z "$host_json" ]]; then
        # Try direct execution
        ssh "$name" "$@"
        return
    fi

    local ssh_cmd=$(build_ssh_cmd "$host_json")

    $ssh_cmd "$@"
}

cmd_copy_id() {
    local name="$1"

    if [[ -z "$name" ]]; then
        log_error "Host name required"
        exit 1
    fi

    local host_json=$(get_host "$name")

    if [[ -z "$host_json" ]]; then
        ssh-copy-id "$name"
        return
    fi

    local host=$(echo "$host_json" | python3 -c "import json,sys; h=json.load(sys.stdin); print(h.get('host',''))")
    local user=$(echo "$host_json" | python3 -c "import json,sys; h=json.load(sys.stdin); print(h.get('user',''))")
    local port=$(echo "$host_json" | python3 -c "import json,sys; h=json.load(sys.stdin); print(h.get('port',22))")

    ssh-copy-id -p "$port" "${user}@${host}"

    log_success "SSH key copied to $name"
}

cmd_status() {
    echo -e "${BOLD}Remote Host Status${NC}"
    echo ""

    init_hosts

    local hosts=$(list_hosts)

    if [[ -z "$hosts" ]]; then
        echo "No hosts configured"
        return
    fi

    echo "$hosts" | while read -r name; do
        local host_json=$(get_host "$name")
        local host=$(echo "$host_json" | python3 -c "import json,sys; h=json.load(sys.stdin); print(h.get('host',''))")
        local user=$(echo "$host_json" | python3 -c "import json,sys; h=json.load(sys.stdin); print(h.get('user',''))")
        local port=$(echo "$host_json" | python3 -c "import json,sys; h=json.load(sys.stdin); print(h.get('port',22))")

        # Quick connectivity check
        if nc -z -w 2 "$host" "$port" 2>/dev/null; then
            echo -e "  ${GREEN}●${NC} $name (${user}@${host}:${port})"
        else
            echo -e "  ${RED}●${NC} $name (${user}@${host}:${port}) - unreachable"
        fi
    done
}

cmd_dev() {
    local name="$1"
    shift || true

    if [[ -z "$name" ]]; then
        log_error "Host name required"
        exit 1
    fi

    local host_json=$(get_host "$name")

    if [[ -z "$host_json" ]]; then
        log_error "Host not found: $name"
        exit 1
    fi

    local ssh_cmd=$(build_ssh_cmd "$host_json" "-t")
    local remote_path=$(echo "$host_json" | python3 -c "import json,sys; h=json.load(sys.stdin); print(h.get('path','') or '~')")

    log_info "Starting dev session on $name..."

    # Start tmux session on remote
    $ssh_cmd "cd $remote_path && (tmux attach -t dev 2>/dev/null || tmux new-session -s dev)"
}

cmd_shell() {
    local name="$1"
    shift || true

    cmd_connect "$name" "$@"
}

main() {
    local cmd="${1:-help}"

    case "$cmd" in
        help|--help|-h)
            cmd_help
            ;;
        connect|c|ssh)
            shift
            cmd_connect "$@"
            ;;
        add|a)
            shift
            cmd_add "$@"
            ;;
        remove|rm|delete)
            shift
            cmd_remove "$@"
            ;;
        list|ls)
            cmd_list
            ;;
        edit)
            shift
            cmd_edit "$@"
            ;;
        sync|s)
            shift
            cmd_sync "$@"
            ;;
        tunnel|t)
            shift
            cmd_tunnel "$@"
            ;;
        exec|e)
            shift
            cmd_exec "$@"
            ;;
        copy-id|copy)
            shift
            cmd_copy_id "$@"
            ;;
        status|st)
            cmd_status
            ;;
        dev|d)
            shift
            cmd_dev "$@"
            ;;
        shell|sh)
            shift
            cmd_shell "$@"
            ;;
        version|--version|-V)
            echo "remote $REMOTE_VERSION"
            ;;
        *)
            log_error "Unknown command: $cmd"
            echo "Run 'remote help' for usage"
            exit 1
            ;;
    esac
}

main "$@"
