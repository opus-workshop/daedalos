================================================================================
                          SPEC TOOL SPECIFICATION
                       Rich Specification System v1.0
================================================================================

OVERVIEW
--------
The `spec` tool manages rich specifications for Daedalos components. Unlike
simple documentation, specs are structured data that agents can query and
humans can read. They capture not just WHAT something does, but WHY it exists,
what alternatives were rejected, and what to avoid.

================================================================================
                              THE PROBLEM
================================================================================

AI agents work better with more specification. But traditional docs fail:
- They describe WHAT but not WHY
- They don't capture rejected alternatives
- They lack concrete examples of usage scenarios
- They become stale and drift from implementation
- They're monolithic - can't query specific sections

The spec system solves this with structured, queryable, maintainable specs.

================================================================================
                              SPEC FORMAT
================================================================================

Each component has a single `.spec.yaml` file containing:

REQUIRED SECTIONS:
  name          - Component identifier
  intent        - WHY this exists (not what it does)
  constraints   - Hard requirements and boundaries
  interface     - The contract (commands, API, etc.)

OPTIONAL SECTIONS:
  examples      - Concrete usage scenarios
  decisions     - Choices made and alternatives rejected
  anti_patterns - What NOT to do
  connects_to   - Related components
  metrics       - How to measure success

--------------------------------------------------------------------------------

EXAMPLE SPEC:

```yaml
name: undo
version: 1.0

intent: |
  Users should experiment fearlessly. Every change is reversible.
  The undo system is a time machine, not a backup tool. It should
  feel instant and invisible until needed, then be there reliably.

  The key insight: mistakes are cheap if you can always go back.

constraints:
  - Must work without Btrfs (git fallback required)
  - Sub-second for recent changes (< 100 entries)
  - No external dependencies beyond git and sqlite
  - Works offline, no network required
  - Max 1GB storage per project by default

interface:
  commands:
    timeline:
      args: "[-n count] [--file path] [--json]"
      returns: "List of changes with timestamps"
    last:
      args: "[n] [--file path] [--dry-run]"
      returns: "Reverts last n changes"
    checkpoint:
      args: "[name]"
      returns: "Creates named restore point"
    restore:
      args: "<reference> [--dry-run]"
      returns: "Restores to reference point"

  exit_codes:
    0: success
    1: undo failed
    2: config error
    3: storage error
    4: nothing to undo

examples:
  - scenario: "User breaks something during refactor"
    context: "Made 5 edits, last one introduced a bug"
    action: "undo last"
    result: "Previous file state restored, user sees what changed"
    why_it_matters: "No mental overhead of git stash/checkout"

  - scenario: "User wants to try risky approach"
    context: "About to delete half the codebase"
    action: "undo checkpoint 'before-massacre'"
    result: "Named point created, user proceeds fearlessly"
    why_it_matters: "Encourages experimentation"

  - scenario: "Agent is iterating on a fix"
    context: "Loop is running, making multiple attempts"
    action: "System auto-checkpoints each iteration"
    result: "Any iteration can be restored"
    why_it_matters: "Loops become truly reversible"

decisions:
  - choice: "File-level granularity, not line-level"
    why: |
      Line-level sounds more precise but adds complexity.
      File-level matches mental model better ("undo that edit").
      Btrfs CoW makes file copies cheap anyway.
    alternatives:
      - option: "Line-level patches"
        rejected_because: "Complex, fragile, overkill"
      - option: "Git stash only"
        rejected_because: "Too git-specific, poor UX"

  - choice: "SQLite for metadata, not filesystem"
    why: |
      Queries are fast. Timeline is structured data.
      Atomic transactions prevent corruption.
    alternatives:
      - option: "JSON files"
        rejected_because: "No atomic writes, slow queries"
      - option: "Git notes"
        rejected_because: "Couples to git, weird semantics"

  - choice: "Hybrid storage (inline + file)"
    why: |
      Small files inline in SQLite (fast, atomic).
      Large files compressed on disk (space efficient).
      Threshold at 100KB balances both.

anti_patterns:
  - pattern: "Requiring users to name every checkpoint"
    why_bad: "Friction kills adoption. Auto-generate names."

  - pattern: "Showing raw git output"
    why_bad: "Leaks abstraction. Users don't care about git."

  - pattern: "Prompting for confirmation on every undo"
    why_bad: "Undo should be instant. Undo-the-undo is the safety."

  - pattern: "Losing data silently on storage errors"
    why_bad: "Better to fail loudly than corrupt silently."

connects_to:
  - component: loop
    relationship: "Loop creates checkpoints per iteration"
  - component: scratch
    relationship: "Scratch envs use same undo timeline"
  - component: verify
    relationship: "Verify failure can trigger undo suggestion"

metrics:
  success_criteria:
    - "< 100ms for undo last"
    - "< 500ms for timeline display"
    - "Users undo without thinking about it"
  failure_indicators:
    - "Users reach for git instead"
    - "Storage fills up unexpectedly"
```

================================================================================
                              PROJECT INDEX
================================================================================

Each project has a `.daedalos/specs/index.yaml`:

```yaml
version: 1.0
project: daedalos

# Component specs
components:
  undo: daedalos-tools/undo/undo.spec.yaml
  loop: daedalos-tools/loop/loop.spec.yaml
  verify: daedalos-tools/verify/verify.spec.yaml
  # ... etc

# Project-wide specs
project_specs:
  conventions: docs/conventions.spec.yaml
  architecture: docs/architecture.spec.yaml
  decisions: docs/decisions.spec.yaml

# Auto-discovered (tool scans for *.spec.yaml)
auto_discover: true
scan_paths:
  - daedalos-tools/
  - docs/
```

================================================================================
                              COMMANDS
================================================================================

spec show <component>
---------------------
Display the spec for a component.

Options:
  --section <name>    Show only one section (intent, constraints, etc.)
  --json              Output as JSON
  --yaml              Output as YAML (default)

Examples:
  spec show undo
  spec show undo --section intent
  spec show undo --section decisions

--------------------------------------------------------------------------------

spec query <query>
------------------
Search across all specs semantically.

Examples:
  spec query "what handles file backups"
  spec query "why did we choose sqlite"
  spec query "what should I avoid with undo"

Returns relevant sections from matching specs.

--------------------------------------------------------------------------------

spec list
---------
List all specs in the project.

Options:
  --missing    Show components without specs
  --stale      Show specs older than their implementation

--------------------------------------------------------------------------------

spec new <name>
---------------
Create a new spec from template.

Options:
  --type <type>    Type: tool, library, service, doc (default: tool)

Creates:
  <path>/<name>.spec.yaml

Interactive prompts for required sections.

--------------------------------------------------------------------------------

spec validate [path]
--------------------
Validate spec format and completeness.

Checks:
  - Required sections present
  - YAML syntax valid
  - References to other components exist
  - No orphan specs (component deleted)

--------------------------------------------------------------------------------

spec diff <component>
---------------------
Show differences between spec and implementation.

Detects:
  - Commands in spec not in code
  - Commands in code not in spec
  - Exit codes mismatch
  - Structural drift

--------------------------------------------------------------------------------

spec context <task>
-------------------
Get relevant spec sections for a task.

Used by agents to load context before working:
  spec context "fix the undo restore command"

Returns: intent, relevant interface section, anti_patterns

--------------------------------------------------------------------------------

spec inject
-----------
Add spec context to CLAUDE.md or similar.

Options:
  --component <name>   Inject specific component
  --all                Inject all component intents
  --format <fmt>       Output format (markdown, yaml)

================================================================================
                              DATA LOCATIONS
================================================================================

Specs:           <project>/<component>/<component>.spec.yaml
Index:           <project>/.daedalos/specs/index.yaml
Cache:           ~/.local/share/daedalos/spec-cache/

================================================================================
                              INTEGRATION
================================================================================

WITH LOOP:
  When loop starts, auto-load relevant specs based on task.
  loop start "fix undo restore"
    → loads undo.spec.yaml intent, interface, anti_patterns

WITH CODEX:
  Specs are indexed for semantic search.
  codex search "why file-level not line-level"
    → finds undo decisions section

WITH PROJECT:
  project info includes spec summary.
  project conventions pulls from conventions.spec.yaml

WITH AGENTS:
  Before starting work, agents query:
    spec context "<task description>"
  Receives focused context, not entire spec.

================================================================================
                              MIGRATION
================================================================================

Migrate from SPEC.txt + prompt.txt:

1. Extract intent (usually missing - needs writing)
2. Extract constraints from requirements
3. Extract interface from commands section
4. Add examples (usually missing - needs writing)
5. Document decisions (usually missing - needs writing)
6. Add anti_patterns (usually missing - needs writing)
7. Map connections to other tools

The migration is NOT automatic - it requires thought about
WHY and WHAT NOT TO DO, which don't exist in old specs.

================================================================================
                              EXIT CODES
================================================================================

0 - Success
1 - Spec not found
2 - Invalid spec format
3 - Validation failed

================================================================================
