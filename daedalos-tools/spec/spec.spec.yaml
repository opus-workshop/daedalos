name: spec
version: 1.0
created: 2025-01-11

intent: |
  AI agents work dramatically better with rich specifications.

  Traditional documentation fails agents because it describes WHAT but not
  WHY, doesn't capture rejected alternatives (so agents re-propose them),
  lacks concrete examples, and becomes stale. Specs solve this with
  structured, queryable, maintainable documentation.

  The key insight: specs are not for humans to read linearly - they're
  for agents to query contextually. An agent working on "fix undo restore"
  should get exactly the undo intent, interface, and anti-patterns -
  not a 500-line document.

  This is spec-driven development: invest in specification upfront,
  get compound returns as agents use it repeatedly.

constraints:
  - YAML format (structured but human-editable)
  - Single file per component (no fragmentation)
  - Required sections: name, intent, constraints, interface
  - Must work without network (local queries only)
  - Queries should complete in < 100ms
  - No external dependencies beyond python3 and yq

interface:
  commands:
    show:
      args: "<component> [--section name] [--json|--yaml]"
      returns: "Full spec or specific section"
      example: "spec show undo --section intent"

    query:
      args: "<query>"
      returns: "Relevant sections from matching specs"
      example: "spec query 'why sqlite'"

    list:
      args: "[--missing] [--stale]"
      returns: "All specs, optionally filtered"
      example: "spec list --missing"

    new:
      args: "<name> [--type tool|library|service|doc]"
      returns: "Creates spec from template"
      example: "spec new my-tool"

    validate:
      args: "[path]"
      returns: "Validation results for all specs"
      example: "spec validate"

    diff:
      args: "<component>"
      returns: "Comparison of spec vs implementation"
      example: "spec diff undo"

    context:
      args: "<task description>"
      returns: "Relevant spec sections for task"
      example: "spec context 'fix undo restore'"

    inject:
      args: "--component <name> | --all [--format markdown|yaml]"
      returns: "Spec content formatted for context injection"
      example: "spec inject --all --format markdown"

    index:
      args: "[rebuild|show]"
      returns: "Manages spec index"
      example: "spec index rebuild"

  exit_codes:
    0: success
    1: spec not found
    2: invalid spec format
    3: validation failed

examples:
  - scenario: "Agent starting work on a component"
    context: "About to fix a bug in undo restore"
    action: "spec context 'fix undo restore command'"
    result: "Gets intent, relevant interface, anti-patterns for undo"
    why_it_matters: "Agent has focused context, not entire codebase"

  - scenario: "Developer wondering why a choice was made"
    context: "Sees SQLite used, wonders why not simple files"
    action: "spec query 'why sqlite'"
    result: "Finds undo decisions section explaining the choice"
    why_it_matters: "No relitigating settled decisions"

  - scenario: "Creating a new tool"
    context: "Adding a new Daedalos tool"
    action: "spec new my-tool --type tool"
    result: "Creates my-tool.spec.yaml with template to fill in"
    why_it_matters: "Encourages spec-first development"

  - scenario: "Checking for spec drift"
    context: "Implementation evolved, spec might be stale"
    action: "spec diff undo"
    result: "Shows commands in spec but not code, and vice versa"
    why_it_matters: "Keeps specs and implementation synchronized"

decisions:
  - choice: "Single YAML file per component, not multiple files"
    why: |
      Fragmentation (intent.txt, decisions.txt, etc.) creates discovery
      problems and sync issues. A single file is:
      - Easy to find (component-name.spec.yaml)
      - Atomic to update
      - Self-contained context

      YAML sections provide internal structure without file fragmentation.
    alternatives:
      - option: "Multiple markdown files per component"
        rejected_because: "Discovery problem, sync issues, harder to query"
      - option: "Single giant project spec"
        rejected_because: "Too coarse, can't query per-component"

  - choice: "YAML over JSON or TOML"
    why: |
      YAML allows multi-line strings naturally (for intent, explanations).
      JSON requires escape sequences. TOML is less familiar.
      YAML is readable and editable by humans while being parseable.
    alternatives:
      - option: "JSON"
        rejected_because: "Multi-line strings are painful, less readable"
      - option: "Markdown with frontmatter"
        rejected_because: "Hard to extract specific sections programmatically"

  - choice: "Required sections: name, intent, constraints, interface"
    why: |
      These four capture the minimum useful spec:
      - name: identity
      - intent: WHY (the most often missing piece)
      - constraints: boundaries and requirements
      - interface: the contract

      Other sections (examples, decisions, anti_patterns) are valuable
      but optional - a minimal spec is better than no spec.

  - choice: "spec context returns focused excerpts, not full specs"
    why: |
      Context windows are limited. Full specs waste tokens.
      For a task like "fix undo restore", the agent needs:
      - Intent (understand the purpose)
      - Relevant interface (the restore command specifically)
      - Anti-patterns (what to avoid)

      NOT: all examples, all decisions, full command list.

anti_patterns:
  - pattern: "Writing specs after implementation"
    why_bad: |
      Specs should drive implementation, not document it after.
      Post-hoc specs miss the WHY - you've already forgotten
      alternatives you considered. Write specs first.

  - pattern: "Copying implementation details into spec"
    why_bad: |
      Spec describes WHAT and WHY, not HOW. Implementation details
      in specs create staleness - code changes but spec doesn't.
      If you're writing code in the spec, you've gone too far.

  - pattern: "Empty anti_patterns section"
    why_bad: |
      Every project has learned lessons about what NOT to do.
      Empty anti_patterns suggests you haven't thought about it
      or haven't captured tribal knowledge.

  - pattern: "Vague intent like 'provides undo functionality'"
    why_bad: |
      That's WHAT, not WHY. Intent should answer:
      - Why does this exist?
      - What experience should users have?
      - What problem does this solve emotionally?

      Good: "Users should experiment fearlessly"
      Bad: "Provides file-level undo"

  - pattern: "Specs that are never queried"
    why_bad: |
      If agents aren't loading specs before working, the investment
      is wasted. Integrate spec loading into workflows (loop, etc.)

connects_to:
  - component: loop
    relationship: |
      When loop starts a task, it should:
      1. Parse task description for component names
      2. Load relevant specs via 'spec context'
      3. Include in agent system prompt

      This makes loops spec-aware automatically.

  - component: project
    relationship: |
      'project info' includes spec summary.
      'project conventions' pulls from conventions.spec.yaml if present.

  - component: codex
    relationship: |
      Specs are indexed for semantic search.
      'codex search' can find decision rationale in specs.

metrics:
  success_criteria:
    - "Agents query specs before starting work"
    - "spec context returns in < 100ms"
    - "New tools start with spec new, not mkdir"
    - "Decision questions get answered by 'spec query'"
    - "Spec validation passes in CI"

  failure_indicators:
    - "Agents re-propose rejected alternatives"
    - "Same mistakes repeated (anti-patterns not consulted)"
    - "Specs drift from implementation (spec diff shows mismatches)"
    - "Developers ask 'why did we...' repeatedly"
