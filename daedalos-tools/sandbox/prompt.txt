================================================================================
                       SANDBOX - ONE-SHOT BUILD PROMPT
================================================================================

You are building the `sandbox` tool for Daedalos, a Linux distribution designed
for AI-assisted development. Sandbox creates isolated, disposable environments
for experimentation.

================================================================================
                              WHAT YOU'RE BUILDING
================================================================================

The `sandbox` command creates isolated copies of directories where you can
experiment freely. Changes in a sandbox don't affect the original until you
explicitly promote them.

Core use case: "I want to try a risky refactor without fear of breaking things."

================================================================================
                              ARCHITECTURE
================================================================================

Create these files:

sandbox/
├── sandbox                   # Main CLI entry point (Bash)
├── lib/
│   ├── __init__.py
│   ├── backends/
│   │   ├── __init__.py
│   │   ├── btrfs.py          # Btrfs snapshot backend
│   │   ├── overlay.py        # OverlayFS backend
│   │   └── rsync.py          # Simple copy backend
│   ├── network.py            # Network isolation
│   ├── state.py              # Sandbox state management
│   └── ui.py                 # Terminal UI helpers
├── completions/
│   ├── sandbox.bash
│   ├── sandbox.zsh
│   └── sandbox.fish
└── tests/
    ├── test_backends.py
    └── test_sandbox.py

================================================================================
                              MAIN CLI (sandbox)
================================================================================

```bash
#!/usr/bin/env bash
# sandbox - Ephemeral experiment environments for Daedalos

set -euo pipefail

SANDBOX_VERSION="1.0.0"
SANDBOX_ROOT="${SANDBOX_ROOT:-$HOME/.local/share/daedalos/sandbox}"
SANDBOX_CONFIG="${XDG_CONFIG_HOME:-$HOME/.config}/daedalos/sandbox"

mkdir -p "$SANDBOX_ROOT" "$SANDBOX_CONFIG"

# Detect available backend
detect_backend() {
    local path="${1:-.}"

    # Try Btrfs first
    if command -v btrfs &>/dev/null; then
        if btrfs subvolume show "$path" &>/dev/null 2>&1; then
            echo "btrfs"
            return
        fi
    fi

    # Try OverlayFS
    if grep -q overlay /proc/filesystems 2>/dev/null; then
        echo "overlay"
        return
    fi

    # Fallback to rsync
    echo "rsync"
}

generate_name() {
    # Generate memorable sandbox name
    local adjectives=("quick" "bold" "calm" "deep" "fast" "keen" "warm" "cool")
    local nouns=("fox" "owl" "elk" "bee" "ant" "ray" "oak" "ivy")

    local adj=${adjectives[$RANDOM % ${#adjectives[@]}]}
    local noun=${nouns[$RANDOM % ${#nouns[@]}]}
    local num=$((RANDOM % 100))

    echo "${adj}-${noun}-${num}"
}

cmd_create() {
    local name=""
    local source_dir="$(pwd)"
    local backend=""
    local isolated_network=false
    local allowed_ports=""

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --from|-f)
                source_dir="$2"
                shift 2
                ;;
            --copy)
                backend="$2"
                shift 2
                ;;
            --isolated-network)
                isolated_network=true
                shift
                ;;
            --with-ports)
                allowed_ports="$2"
                shift 2
                ;;
            -*)
                echo "Unknown option: $1" >&2
                exit 1
                ;;
            *)
                name="$1"
                shift
                ;;
        esac
    done

    # Generate name if not provided
    [[ -z "$name" ]] && name=$(generate_name)

    # Detect backend if not specified
    [[ -z "$backend" ]] && backend=$(detect_backend "$source_dir")

    # Create sandbox via Python library
    python3 -m sandbox.create \
        --name "$name" \
        --source "$source_dir" \
        --backend "$backend" \
        ${isolated_network:+--isolated-network} \
        ${allowed_ports:+--with-ports "$allowed_ports"}

    echo "Sandbox '$name' created."
    echo "Enter with: sandbox enter $name"
}

cmd_enter() {
    local name="$1"
    local sandbox_path="$SANDBOX_ROOT/$name/work"

    if [[ ! -d "$sandbox_path" ]]; then
        echo "Sandbox '$name' not found" >&2
        exit 2
    fi

    # Set environment and spawn shell
    export SANDBOX_NAME="$name"
    export SANDBOX_SOURCE=$(cat "$SANDBOX_ROOT/$name/source")
    export SANDBOX_CREATED=$(cat "$SANDBOX_ROOT/$name/created")
    export IN_SANDBOX=1

    # Modify prompt to show sandbox context
    export PS1="[sandbox:$name] $PS1"

    cd "$sandbox_path"
    exec "${SHELL:-/bin/bash}"
}

cmd_list() {
    python3 -m sandbox.list "$@"
}

cmd_diff() {
    local name="$1"
    shift
    python3 -m sandbox.diff --name "$name" "$@"
}

cmd_promote() {
    local name="$1"
    shift

    echo "This will apply sandbox changes to the original directory."
    read -p "Continue? [y/N] " confirm
    if [[ "$confirm" != [yY]* ]]; then
        echo "Aborted."
        exit 0
    fi

    python3 -m sandbox.promote --name "$name" "$@"
    echo "Sandbox '$name' promoted successfully."
}

cmd_discard() {
    local name="$1"
    local force=false

    [[ "${2:-}" == "-f" || "${2:-}" == "--force" ]] && force=true

    if [[ "$force" != true ]]; then
        read -p "Discard sandbox '$name'? This cannot be undone. [y/N] " confirm
        if [[ "$confirm" != [yY]* ]]; then
            echo "Aborted."
            exit 0
        fi
    fi

    python3 -m sandbox.discard --name "$name"
    echo "Sandbox '$name' discarded."
}

cmd_info() {
    local name="$1"
    python3 -m sandbox.info --name "$name"
}

cmd_run() {
    local name="$1"
    shift
    local command="$*"

    local sandbox_path="$SANDBOX_ROOT/$name/work"

    if [[ ! -d "$sandbox_path" ]]; then
        echo "Sandbox '$name' not found" >&2
        exit 2
    fi

    cd "$sandbox_path"
    SANDBOX_NAME="$name" IN_SANDBOX=1 eval "$command"
}

cmd_help() {
    cat <<EOF
sandbox - Ephemeral experiment environments

Usage: sandbox <command> [arguments]

Commands:
  create [name]        Create a new sandbox
  list                 List all sandboxes
  enter <name>         Enter sandbox environment
  diff <name>          Show changes in sandbox
  promote <name>       Apply sandbox changes to source
  discard <name>       Delete sandbox
  sync <name>          Sync sandbox with source
  fork <name> <new>    Create sandbox from sandbox
  run <name> <cmd>     Run command in sandbox
  info <name>          Show sandbox details

Options:
  --help, -h           Show this help
  --version            Show version

Examples:
  sandbox create                        # Quick sandbox of current dir
  sandbox create risky-refactor         # Named sandbox
  sandbox enter risky-refactor          # Work in sandbox
  sandbox diff risky-refactor           # See what changed
  sandbox promote risky-refactor        # Apply changes
  sandbox discard risky-refactor        # Throw it away

EOF
}

main() {
    case "${1:-help}" in
        create)     shift; cmd_create "$@" ;;
        list)       shift; cmd_list "$@" ;;
        enter)      shift; cmd_enter "$@" ;;
        diff)       shift; cmd_diff "$@" ;;
        promote)    shift; cmd_promote "$@" ;;
        discard)    shift; cmd_discard "$@" ;;
        sync)       shift; cmd_sync "$@" ;;
        fork)       shift; cmd_fork "$@" ;;
        pause)      shift; cmd_pause "$@" ;;
        resume)     shift; cmd_resume "$@" ;;
        run)        shift; cmd_run "$@" ;;
        info)       shift; cmd_info "$@" ;;
        version)    echo "sandbox $SANDBOX_VERSION" ;;
        help|--help|-h) cmd_help ;;
        *)          echo "Unknown command: $1"; cmd_help; exit 1 ;;
    esac
}

main "$@"
```

================================================================================
                           BTRFS BACKEND (btrfs.py)
================================================================================

```python
"""Btrfs snapshot backend for sandbox - instant, space-efficient isolation."""

import subprocess
from pathlib import Path
from typing import Optional
import json
from datetime import datetime


class BtrfsBackend:
    """Create sandboxes using Btrfs copy-on-write snapshots."""

    def __init__(self, sandbox_root: Path):
        self.sandbox_root = sandbox_root
        self.sandbox_root.mkdir(parents=True, exist_ok=True)

    def _btrfs(self, *args) -> subprocess.CompletedProcess:
        return subprocess.run(
            ["btrfs"] + list(args),
            capture_output=True,
            text=True
        )

    def is_available(self, path: Path) -> bool:
        """Check if path is on a Btrfs filesystem."""
        result = self._btrfs("subvolume", "show", str(path))
        return result.returncode == 0

    def create(self, name: str, source: Path) -> Path:
        """Create a sandbox as a Btrfs snapshot."""
        sandbox_path = self.sandbox_root / name
        work_path = sandbox_path / "work"

        sandbox_path.mkdir(parents=True, exist_ok=True)

        # Create snapshot
        result = self._btrfs(
            "subvolume", "snapshot",
            str(source),
            str(work_path)
        )

        if result.returncode != 0:
            raise RuntimeError(f"Failed to create snapshot: {result.stderr}")

        # Store metadata
        (sandbox_path / "source").write_text(str(source.absolute()))
        (sandbox_path / "created").write_text(datetime.now().isoformat())
        (sandbox_path / "backend").write_text("btrfs")

        return work_path

    def promote(self, name: str) -> None:
        """Apply sandbox changes back to source."""
        sandbox_path = self.sandbox_root / name
        work_path = sandbox_path / "work"
        source = Path((sandbox_path / "source").read_text().strip())

        # Use rsync to copy changes back
        subprocess.run(
            ["rsync", "-av", "--delete",
             f"{work_path}/", f"{source}/"],
            check=True
        )

    def discard(self, name: str) -> None:
        """Delete a sandbox."""
        sandbox_path = self.sandbox_root / name
        work_path = sandbox_path / "work"

        # Delete the subvolume
        self._btrfs("subvolume", "delete", str(work_path))

        # Clean up metadata
        import shutil
        shutil.rmtree(sandbox_path)

    def diff(self, name: str) -> str:
        """Get diff between sandbox and source."""
        sandbox_path = self.sandbox_root / name
        work_path = sandbox_path / "work"
        source = Path((sandbox_path / "source").read_text().strip())

        result = subprocess.run(
            ["diff", "-rq", str(source), str(work_path)],
            capture_output=True,
            text=True
        )
        return result.stdout

    def size(self, name: str) -> int:
        """Get size of sandbox changes in bytes."""
        sandbox_path = self.sandbox_root / name
        work_path = sandbox_path / "work"

        # Btrfs can show exclusive size (data not shared with source)
        result = self._btrfs("qgroup", "show", "-f", str(work_path))
        # Parse output to get exclusive size
        # This is approximate; real implementation needs parsing
        return 0  # Placeholder

    def list(self) -> list[dict]:
        """List all sandboxes."""
        sandboxes = []
        for sandbox_dir in self.sandbox_root.iterdir():
            if sandbox_dir.is_dir() and (sandbox_dir / "work").exists():
                sandboxes.append({
                    "name": sandbox_dir.name,
                    "source": (sandbox_dir / "source").read_text().strip(),
                    "created": (sandbox_dir / "created").read_text().strip(),
                    "backend": "btrfs"
                })
        return sandboxes
```

================================================================================
                          OVERLAY BACKEND (overlay.py)
================================================================================

```python
"""OverlayFS backend for sandbox - works on any filesystem."""

import subprocess
from pathlib import Path
from typing import Optional
import tempfile
import shutil
from datetime import datetime


class OverlayBackend:
    """Create sandboxes using OverlayFS mounts."""

    def __init__(self, sandbox_root: Path):
        self.sandbox_root = sandbox_root
        self.sandbox_root.mkdir(parents=True, exist_ok=True)

    def create(self, name: str, source: Path) -> Path:
        """Create a sandbox using OverlayFS."""
        sandbox_path = self.sandbox_root / name
        work_path = sandbox_path / "work"      # Merged view
        upper_path = sandbox_path / "upper"     # Changes stored here
        workdir_path = sandbox_path / "workdir" # OverlayFS workdir

        for p in [sandbox_path, work_path, upper_path, workdir_path]:
            p.mkdir(parents=True, exist_ok=True)

        # Mount overlay
        mount_cmd = [
            "mount", "-t", "overlay", "overlay",
            "-o", f"lowerdir={source},upperdir={upper_path},workdir={workdir_path}",
            str(work_path)
        ]

        result = subprocess.run(mount_cmd, capture_output=True, text=True)
        if result.returncode != 0:
            # May need sudo
            result = subprocess.run(["sudo"] + mount_cmd, capture_output=True, text=True)
            if result.returncode != 0:
                raise RuntimeError(f"Failed to mount overlay: {result.stderr}")

        # Store metadata
        (sandbox_path / "source").write_text(str(source.absolute()))
        (sandbox_path / "created").write_text(datetime.now().isoformat())
        (sandbox_path / "backend").write_text("overlay")

        return work_path

    def promote(self, name: str) -> None:
        """Apply changes back to source."""
        sandbox_path = self.sandbox_root / name
        upper_path = sandbox_path / "upper"
        source = Path((sandbox_path / "source").read_text().strip())

        # Copy upper layer to source
        subprocess.run(
            ["rsync", "-av", f"{upper_path}/", f"{source}/"],
            check=True
        )

    def discard(self, name: str) -> None:
        """Unmount and delete sandbox."""
        sandbox_path = self.sandbox_root / name
        work_path = sandbox_path / "work"

        # Unmount
        subprocess.run(["umount", str(work_path)], capture_output=True)
        subprocess.run(["sudo", "umount", str(work_path)], capture_output=True)

        # Remove directory
        shutil.rmtree(sandbox_path, ignore_errors=True)

    def diff(self, name: str) -> str:
        """Show changes (contents of upper layer)."""
        sandbox_path = self.sandbox_root / name
        upper_path = sandbox_path / "upper"

        result = subprocess.run(
            ["find", str(upper_path), "-type", "f"],
            capture_output=True,
            text=True
        )
        return result.stdout

    def list(self) -> list[dict]:
        """List all sandboxes."""
        sandboxes = []
        for sandbox_dir in self.sandbox_root.iterdir():
            if sandbox_dir.is_dir() and (sandbox_dir / "backend").exists():
                if (sandbox_dir / "backend").read_text().strip() == "overlay":
                    sandboxes.append({
                        "name": sandbox_dir.name,
                        "source": (sandbox_dir / "source").read_text().strip(),
                        "created": (sandbox_dir / "created").read_text().strip(),
                        "backend": "overlay"
                    })
        return sandboxes
```

================================================================================
                           RSYNC BACKEND (rsync.py)
================================================================================

```python
"""Rsync backend for sandbox - maximum compatibility."""

import subprocess
from pathlib import Path
import shutil
from datetime import datetime


class RsyncBackend:
    """Create sandboxes using rsync copy - works everywhere."""

    def __init__(self, sandbox_root: Path):
        self.sandbox_root = sandbox_root
        self.sandbox_root.mkdir(parents=True, exist_ok=True)

    def create(self, name: str, source: Path) -> Path:
        """Create sandbox by copying with rsync."""
        sandbox_path = self.sandbox_root / name
        work_path = sandbox_path / "work"

        sandbox_path.mkdir(parents=True, exist_ok=True)

        # Copy source to sandbox
        subprocess.run(
            ["rsync", "-a", f"{source}/", f"{work_path}/"],
            check=True
        )

        # Store metadata
        (sandbox_path / "source").write_text(str(source.absolute()))
        (sandbox_path / "created").write_text(datetime.now().isoformat())
        (sandbox_path / "backend").write_text("rsync")

        return work_path

    def promote(self, name: str) -> None:
        """Copy changes back to source."""
        sandbox_path = self.sandbox_root / name
        work_path = sandbox_path / "work"
        source = Path((sandbox_path / "source").read_text().strip())

        subprocess.run(
            ["rsync", "-av", "--delete", f"{work_path}/", f"{source}/"],
            check=True
        )

    def discard(self, name: str) -> None:
        """Delete sandbox."""
        sandbox_path = self.sandbox_root / name
        shutil.rmtree(sandbox_path)

    def diff(self, name: str) -> str:
        """Show diff between sandbox and source."""
        sandbox_path = self.sandbox_root / name
        work_path = sandbox_path / "work"
        source = Path((sandbox_path / "source").read_text().strip())

        result = subprocess.run(
            ["diff", "-rq", str(source), str(work_path)],
            capture_output=True,
            text=True
        )
        return result.stdout

    def list(self) -> list[dict]:
        """List all sandboxes."""
        sandboxes = []
        for sandbox_dir in self.sandbox_root.iterdir():
            if sandbox_dir.is_dir() and (sandbox_dir / "backend").exists():
                if (sandbox_dir / "backend").read_text().strip() == "rsync":
                    sandboxes.append({
                        "name": sandbox_dir.name,
                        "source": (sandbox_dir / "source").read_text().strip(),
                        "created": (sandbox_dir / "created").read_text().strip(),
                        "backend": "rsync"
                    })
        return sandboxes
```

================================================================================
                        NETWORK ISOLATION (network.py)
================================================================================

```python
"""Network isolation for sandboxes using Linux namespaces."""

import subprocess
import os
from typing import Optional


def create_isolated_network(allowed_ports: Optional[list[int]] = None):
    """
    Create a network namespace with optional port allowlist.

    Uses Linux network namespaces (unshare -n) to isolate network access.
    """
    # This would be called when entering a sandbox with --isolated-network
    pass


def enter_sandbox_with_isolation(
    sandbox_path: str,
    shell: str,
    isolated: bool = False,
    allowed_ports: Optional[list[int]] = None
):
    """Enter sandbox, optionally with network isolation."""
    if isolated:
        # Use unshare to create network namespace
        cmd = ["unshare", "-n", shell]
        if allowed_ports:
            # Set up iptables rules for allowed ports
            # This requires CAP_NET_ADMIN
            pass
        os.execvp("unshare", cmd)
    else:
        os.execvp(shell, [shell])
```

================================================================================
                           SUCCESS CRITERIA
================================================================================

The sandbox tool is complete when:

1. BACKEND SUPPORT
   [ ] Btrfs backend creates instant snapshots
   [ ] OverlayFS backend works on non-Btrfs
   [ ] Rsync backend works everywhere
   [ ] Auto-detection chooses best backend

2. CORE OPERATIONS
   [ ] sandbox create makes isolated copy
   [ ] sandbox enter spawns shell in sandbox
   [ ] sandbox diff shows changes
   [ ] sandbox promote applies changes to source
   [ ] sandbox discard removes sandbox

3. MANAGEMENT
   [ ] sandbox list shows all sandboxes
   [ ] sandbox info shows sandbox details
   [ ] sandbox run executes command in sandbox

4. OPTIONAL FEATURES
   [ ] Network isolation works
   [ ] sandbox fork creates sandbox of sandbox
   [ ] sandbox sync updates sandbox from source

================================================================================
