name: evolve
version: 1.0
created: 2025-01-11

intent: |
  Code wants to become something. Help it get there.

  Evolve exists because code has intent - it was written to solve a problem,
  serve a purpose, realize a vision. But code often falls short of its intent:
  bugs, missing features, architectural gaps, unexplored edge cases.

  Most tools focus on "what's wrong" (linting, testing). Evolve focuses on
  "what's missing" - the gap between what code IS and what it's TRYING TO BE.

  The key insight: you can't improve code without understanding its intent.
  A cache with no TTL isn't "wrong" - it's incomplete relative to its purpose.
  A feature missing error handling isn't "buggy" - it's unfinished.

  Evolve reads intent from specs, commits, tests, and structure. Then it
  identifies the path from current state to full realization of that intent.

  Human equivalent: A senior developer who asks "what are we building toward?"
  before suggesting improvements. Not just "fix this bug" but "here's how this
  component should evolve to fully serve its purpose."

constraints:
  - Must understand intent before suggesting changes
  - Improvements must be tied to intent, not arbitrary "best practices"
  - Missing features must be inferred from intent, not invented
  - Uses existing Daedalos tools (spec, codex, project, resolve)
  - Output must be actionable, not just observations
  - Respects scope - suggests what's missing for THIS intent, not scope creep

interface:
  commands:
    evolve:
      args: "<path> [--json] [--phase PHASE]"
      returns: |
        Intent analysis, current state assessment, missing pieces,
        and suggested evolution path
      example: "evolve src/auth/"

    intent:
      args: "<path>"
      returns: "Just the intent analysis for a component"
      example: "evolve intent src/cache.ts"

    gaps:
      args: "<path>"
      returns: "Just the missing pieces analysis"
      example: "evolve gaps src/api/"

    path:
      args: "<path>"
      returns: "Suggested evolution path with priorities"
      example: "evolve path ."

  phases:
    understand:
      purpose: "Discover what this code is trying to become"
      sources:
        - "Specs (.spec.yaml) - Documented intent, constraints, examples"
        - "README/docs - Stated purpose and goals"
        - "Commit history - Why was this created? What problems solved?"
        - "Tests - What behavior is expected?"
        - "Comments/docstrings - Author explanations"
        - "Naming - What do names suggest about purpose?"
        - "Usage - How is this code used? What depends on it?"
        - "Structure - What does organization imply about scope?"
      output: |
        - Core intent statement
        - Key constraints
        - Implied scope
        - Success criteria (what "done" looks like)

    analyze:
      purpose: "Assess how well current code serves the intent"
      checks:
        - "Implementation vs intent alignment"
        - "Anti-patterns from specs"
        - "Inconsistency with codebase patterns"
        - "Code quality issues"
        - "Refactoring opportunities"
      output: |
        - Issues found with severity
        - Gap between intent and implementation
        - Technical debt
        - Refactoring suggestions

    identify:
      purpose: "Find what's missing to fully realize intent"
      looks_for:
        - "Features implied by intent but not implemented"
        - "Edge cases not handled"
        - "Error scenarios not covered"
        - "Integration points missing"
        - "User needs implied but not addressed"
        - "Scalability gaps"
        - "Security considerations"
        - "Documentation gaps"
      output: |
        - Missing features with reasoning
        - Unhandled scenarios
        - Integration opportunities
        - Documentation needs

    suggest:
      purpose: "Chart path from current state to full intent"
      considers:
        - "Priority: fix before extend"
        - "Dependencies: what enables what"
        - "Risk: safe changes before risky ones"
        - "Value: high impact before low impact"
        - "Sequence: logical order of evolution"
      output: |
        - Prioritized list of improvements
        - Feature additions with reasoning
        - Architectural changes if needed
        - Suggested sequence

examples:
  - scenario: "Evolving a new tool"
    input: "evolve daedalos-tools/resolve/"
    understand: |
      Spec: "Resolve uncertainty through context, not asking"
      Commits: "Add resolve tool for uncertainty resolution"
      Intent: Help agents make confident decisions by gathering context
      Success: Agents rarely ask implementation questions
    analyze: |
      ✓ Intent analysis implemented
      ✓ Context gathering works (spec, codex, project)
      ✓ Decision logging exists
      ⚠ Web search mentioned in spec but not integrated
    identify: |
      Missing:
      - Web search for best practices
      - Conversation history analysis
      - Learning from resolution outcomes
      - AskUserQuestion integration for intent loop
    suggest: |
      1. Add web search (mentioned in spec, easy win)
      2. Track which context sources help most
      3. Build intent question templates
      4. Learn from past resolutions
    why_it_matters: |
      Without understanding resolve's intent, suggestions would be
      arbitrary. With intent, we know web search is a gap (spec mentions it)
      and learning from outcomes serves the goal of confidence.

  - scenario: "Evolving legacy code"
    input: "evolve src/legacy/payment.js"
    understand: |
      Commits: "Added payment processing 2019"
      Tests: Expect charge, refund, subscription handling
      Usage: Called from checkout, subscription renewal, admin panel
      Intent: Process payments reliably for multiple use cases
      Success: All payment scenarios handled, errors recoverable
    analyze: |
      Issues:
      - No retry logic for failed charges
      - Subscription renewal hardcoded to specific provider
      - Error messages expose internal details
    identify: |
      Missing:
      - Provider abstraction (implied by multi-use but hardcoded)
      - Retry with exponential backoff
      - Audit logging for compliance
      - Webhook handling for async events
    suggest: |
      1. Fix error message exposure (security)
      2. Add retry logic (reliability, core intent)
      3. Abstract provider (enables future flexibility)
      4. Add audit logging (compliance, often required)
      5. Webhook support (modern payment flows need this)
    why_it_matters: |
      Legacy code often has implied intent that was never fully realized.
      Evolve surfaces what the code was "trying to become" based on its
      usage patterns and original commits.

  - scenario: "Evolving based on spec"
    input: "evolve daedalos-tools/gates/"
    understand: |
      Spec: Rich specification exists with intent, constraints, anti-patterns
      Intent: "Trust is earned, not given. Control AI autonomy."
      Success criteria from spec:
        - Gate check < 10ms
        - Users find right supervision level
        - History enables audit
    analyze: |
      From spec anti-patterns:
      - Check if "everything allow" is common (defeats purpose)
      - Check if "everything approve" is common (over-supervision)
      From spec decisions:
      - Verify project config only restricts
    identify: |
      From spec connects_to:
      - observe integration mentioned but not tested
      - journal integration - is it logging properly?
      From spec metrics:
      - Are we measuring gate check latency?
      - Are we tracking user satisfaction with levels?
    suggest: |
      1. Add latency tracking (success criteria)
      2. Verify journal integration
      3. Test observe integration
      4. Add analytics for level usage patterns
    why_it_matters: |
      When specs exist, they're the primary source of intent. Evolve
      reads specs directly and checks implementation against them.

decisions:
  - choice: "Intent first, always"
    why: |
      Without understanding intent, suggestions are arbitrary.
      "Add caching" is meaningless without knowing if caching serves
      the component's purpose. "Add tests" is noise without knowing
      what behavior matters.

      Evolve refuses to suggest improvements without first establishing
      what the code is trying to achieve.
    alternatives:
      - option: "Just find issues (linter approach)"
        rejected_because: "Issues without context are noise, not signal"
      - option: "Apply best practices universally"
        rejected_because: "Best practices aren't always relevant to intent"

  - choice: "Specs are primary source when they exist"
    why: |
      Specs encode intent explicitly. When a .spec.yaml exists, it's
      the authoritative source for what the code should be.

      Other sources (commits, tests, naming) are inferred intent.
      Specs are declared intent. Declared wins.
    alternatives:
      - option: "Weight all sources equally"
        rejected_because: "Specs are explicitly written intent, more reliable"
      - option: "Ignore specs, infer everything"
        rejected_because: "Wastes explicit knowledge that exists"

  - choice: "Missing features must be implied, not invented"
    why: |
      Evolve identifies what's missing to serve the intent, not what
      would be "cool" or "modern" to add.

      If the intent is "cache API responses," suggesting "add GraphQL"
      is scope creep. Suggesting "add TTL" serves the caching intent.

      This prevents evolve from becoming a feature factory.
    alternatives:
      - option: "Suggest all possible improvements"
        rejected_because: "Noise drowns signal, scope creep"
      - option: "Only suggest from explicit spec gaps"
        rejected_because: "Too narrow, misses implied needs"

  - choice: "Fix before extend"
    why: |
      Existing issues should be resolved before adding new features.
      A cache with bugs shouldn't get new features - fix the cache first.

      This keeps evolution sustainable. Extending broken code makes
      the broken parts harder to fix later.
    alternatives:
      - option: "Prioritize by impact"
        rejected_because: "Tempting to add flashy features over boring fixes"
      - option: "Let user prioritize"
        rejected_because: "Tool should have opinion based on best practices"

  - choice: "Contain analyze as a subcommand"
    why: |
      Analyze (current state assessment) is a component of evolve.
      Users may want just analysis without the full evolution path.

      "evolve analyze src/foo" gives you the analyze phase only.
      "evolve src/foo" gives you the full evolution.

      Composable phases enable different workflows.
    alternatives:
      - option: "Separate analyze tool"
        rejected_because: "Fragments the evolution workflow"
      - option: "Always run all phases"
        rejected_because: "Sometimes you just want one phase"

anti_patterns:
  - pattern: "Suggesting improvements without understanding intent"
    why_bad: |
      "Add tests" without knowing what matters is noise.
      "Refactor to microservices" without knowing scale needs is wrong.

      Improvements must serve intent. If you can't state the intent,
      you can't meaningfully suggest improvements.

  - pattern: "Inventing features not implied by intent"
    why_bad: |
      Scope creep disguised as improvement. If the intent is "validate
      user input," suggesting "add AI-powered fraud detection" is
      invention, not evolution.

      Missing features must be logically implied by stated intent.

  - pattern: "Ignoring specs when they exist"
    why_bad: |
      Specs are explicit intent. Ignoring them to infer intent from
      code is throwing away information.

      When specs exist, they're the source of truth for what the
      code should become.

  - pattern: "Overwhelming with suggestions"
    why_bad: |
      50 suggestions is the same as 0 - too many to act on.
      Evolve should prioritize ruthlessly and surface the most
      important evolution steps, not everything possible.

  - pattern: "Generic best practice suggestions"
    why_bad: |
      "Add logging" appears everywhere but isn't always relevant.
      "Improve test coverage" is lazy without knowing what to test.

      Suggestions must be specific to this code's intent.

connects_to:
  - component: resolve
    relationship: |
      Resolve handles decision uncertainty. Evolve handles code evolution.
      Both share the philosophy of gathering context before acting.

      Evolve may use resolve internally when uncertain about intent.
      "I'm not sure what this code is trying to do" → resolve.

  - component: spec
    relationship: |
      Specs are the primary source of intent. Evolve reads specs to
      understand what code should become.

      Evolve may suggest spec updates when code has evolved beyond
      its original spec.

  - component: codex
    relationship: |
      Codex provides pattern search. Evolve uses codex to find
      how similar problems are solved elsewhere in codebase.

      "This component doesn't handle errors, but similar ones do"
      → suggests error handling is missing.

  - component: project
    relationship: |
      Project provides codebase context. Evolve uses project info
      to understand conventions and structure.

  - component: loop
    relationship: |
      Evolve identifies what to improve. Loop executes the improvement.

      "evolve src/cache/" → identifies TTL is missing
      "loop start 'add TTL to cache' --promise 'npm test'" → implements it

  - component: review
    relationship: |
      After evolve suggests and loop implements, review verifies.
      The evolution cycle: evolve → loop → verify → review.

metrics:
  success_criteria:
    - "Intent accurately extracted from available sources"
    - "Suggestions directly serve identified intent"
    - "Missing features are implied, not invented"
    - "Prioritization reflects fix-before-extend"
    - "Users act on suggestions (they're valuable)"
    - "Evolution path is achievable, not overwhelming"

  failure_indicators:
    - "Suggestions feel generic/templated"
    - "Intent extraction misses the point"
    - "Suggested features are scope creep"
    - "Too many suggestions to be actionable"
    - "Suggestions ignore existing specs"
    - "Users ignore evolve output (not useful)"
