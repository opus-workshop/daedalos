================================================================================
                         VERIFY CLI BUILD PROMPT
================================================================================

You are building the `verify` CLI tool for ClaudeOS - a universal project
verification tool that auto-detects project type and runs appropriate
linting, type checking, building, and testing pipelines.

================================================================================
                              YOUR TASK
================================================================================

Build a complete, production-ready CLI tool with:

1. Main executable: verify (bash script)
2. Library functions: lib/*.sh
3. Pipeline definitions: pipelines/*.yaml
4. Tests: tests/*.sh

================================================================================
                              ARCHITECTURE
================================================================================

File structure to create:

verify/
  bin/
    verify                  # Main executable
  lib/
    common.sh               # Shared utilities
    detect.sh               # Project/tool detection
    runner.sh               # Step execution
    output.sh               # Output formatting
    watch.sh                # Watch mode
  pipelines/
    swift.yaml
    typescript.yaml
    python.yaml
    rust.yaml
    go.yaml
  tests/
    test_detect.sh
    test_runner.sh
    run_tests.sh
  install.sh
  README.txt

================================================================================
                              IMPLEMENTATION
================================================================================

MAIN EXECUTABLE (bin/verify):
-----------------------------
#!/usr/bin/env bash
set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
LIB_DIR="${SCRIPT_DIR}/../lib"
PIPELINES_DIR="${SCRIPT_DIR}/../pipelines"

source "${LIB_DIR}/common.sh"
source "${LIB_DIR}/detect.sh"
source "${LIB_DIR}/runner.sh"
source "${LIB_DIR}/output.sh"
source "${LIB_DIR}/watch.sh"

# Default options
QUICK=false
STAGED=false
WATCH=false
FIX=false
VERBOSE=false
QUIET=false
JSON=false
PIPELINE=""
ONLY_STEP=""
SKIP_STEPS=()

# Parse arguments
while [[ $# -gt 0 ]]; do
    case "$1" in
        -q|--quick)   QUICK=true; shift ;;
        --staged)     STAGED=true; shift ;;
        -w|--watch)   WATCH=true; shift ;;
        --fix)        FIX=true; shift ;;
        -v|--verbose) VERBOSE=true; shift ;;
        --quiet)      QUIET=true; shift ;;
        --json)       JSON=true; shift ;;
        --pipeline)   PIPELINE="$2"; shift 2 ;;
        --step)       ONLY_STEP="$2"; shift 2 ;;
        --skip)       SKIP_STEPS+=("$2"); shift 2 ;;
        -h|--help)    show_help; exit 0 ;;
        status)       cmd_status; exit 0 ;;
        pipelines)    cmd_pipelines; exit 0 ;;
        init)         cmd_init; exit 0 ;;
        *)
            if [[ -d "$1" ]]; then
                PROJECT_PATH="$1"
                shift
            else
                die "Unknown option: $1"
            fi
            ;;
    esac
done

PROJECT_PATH="${PROJECT_PATH:-.}"
cd "$PROJECT_PATH"

# Main execution
if $WATCH; then
    run_watch_mode
else
    run_verification
fi

--------------------------------------------------------------------------------

DETECTION LIBRARY (lib/detect.sh):
----------------------------------
detect_project_type() {
    local path="${1:-.}"

    # Check for indicator files
    if [[ -f "$path/package.json" ]]; then
        if [[ -f "$path/tsconfig.json" ]]; then
            echo "typescript"
        else
            echo "javascript"
        fi
    elif [[ -f "$path/Cargo.toml" ]]; then
        echo "rust"
    elif [[ -f "$path/go.mod" ]]; then
        echo "go"
    elif [[ -d "$path"/*.xcodeproj ]] || [[ -f "$path/Package.swift" ]]; then
        echo "swift"
    elif [[ -f "$path/pyproject.toml" ]] || [[ -f "$path/setup.py" ]]; then
        echo "python"
    else
        echo "unknown"
    fi
}

detect_package_manager() {
    local path="${1:-.}"

    if [[ -f "$path/pnpm-lock.yaml" ]]; then
        echo "pnpm"
    elif [[ -f "$path/yarn.lock" ]]; then
        echo "yarn"
    elif [[ -f "$path/bun.lockb" ]]; then
        echo "bun"
    elif [[ -f "$path/package-lock.json" ]]; then
        echo "npm"
    else
        echo "npm"  # Default
    fi
}

detect_tool() {
    local tool="$1"
    command -v "$tool" &>/dev/null
}

detect_xcode_scheme() {
    local path="${1:-.}"

    # Find xcodeproj
    local xcodeproj
    xcodeproj=$(find "$path" -maxdepth 1 -name "*.xcodeproj" -print -quit)

    if [[ -n "$xcodeproj" ]]; then
        # List schemes
        xcodebuild -project "$xcodeproj" -list 2>/dev/null | \
            awk '/Schemes:/{found=1; next} found && /^[[:space:]]+/{print; next} found{exit}' | \
            head -1 | tr -d '[:space:]'
    fi
}

load_pipeline() {
    local type="$1"
    local pipeline_file="${PIPELINES_DIR}/${type}.yaml"

    if [[ ! -f "$pipeline_file" ]]; then
        die "No pipeline found for project type: $type"
    fi

    # Parse YAML (simplified - use yq if available, else basic parsing)
    if command -v yq &>/dev/null; then
        yq -o=json "$pipeline_file"
    else
        # Basic YAML parsing for our simple format
        parse_simple_yaml "$pipeline_file"
    fi
}

--------------------------------------------------------------------------------

RUNNER LIBRARY (lib/runner.sh):
-------------------------------
run_verification() {
    local start_time
    start_time=$(date +%s%3N)

    # Detect or use specified pipeline
    if [[ -z "$PIPELINE" ]]; then
        PIPELINE=$(detect_project_type)
    fi

    if [[ "$PIPELINE" == "unknown" ]]; then
        die "Could not detect project type. Use --pipeline to specify."
    fi

    # Load pipeline
    local pipeline_config
    pipeline_config=$(load_pipeline "$PIPELINE")

    # Get steps
    local steps
    steps=$(get_steps "$pipeline_config")

    # Filter steps
    if $QUICK; then
        steps=$(filter_quick_steps "$steps")
    fi
    if [[ -n "$ONLY_STEP" ]]; then
        steps=$(filter_only_step "$steps" "$ONLY_STEP")
    fi
    for skip in "${SKIP_STEPS[@]}"; do
        steps=$(filter_skip_step "$steps" "$skip")
    done

    # Run steps
    local results=()
    local all_passed=true

    for step in $steps; do
        local step_name step_cmd step_timeout
        step_name=$(get_step_name "$step")
        step_cmd=$(get_step_command "$step")
        step_timeout=$(get_step_timeout "$step")

        # Handle fix mode
        if $FIX; then
            local fix_cmd
            fix_cmd=$(get_step_fix_command "$step")
            if [[ -n "$fix_cmd" ]]; then
                step_cmd="$fix_cmd"
            fi
        fi

        # Handle staged mode
        if $STAGED; then
            step_cmd=$(adapt_for_staged "$step_cmd")
        fi

        # Substitute variables
        step_cmd=$(substitute_vars "$step_cmd")

        # Run step
        local step_start step_end step_duration step_output step_exit_code
        step_start=$(date +%s%3N)

        if $VERBOSE; then
            step_output=$(timeout "${step_timeout}s" bash -c "$step_cmd" 2>&1) || step_exit_code=$?
        else
            step_output=$(timeout "${step_timeout}s" bash -c "$step_cmd" 2>&1) || step_exit_code=$?
        fi
        step_exit_code=${step_exit_code:-0}

        step_end=$(date +%s%3N)
        step_duration=$((step_end - step_start))

        # Record result
        results+=("$(format_result "$step_name" "$step_exit_code" "$step_duration" "$step_output")")

        if [[ $step_exit_code -ne 0 ]]; then
            all_passed=false
        fi

        # Output progress
        if ! $QUIET && ! $JSON; then
            print_step_result "$step_name" "$step_exit_code" "$step_duration"
            if [[ $step_exit_code -ne 0 ]] && [[ -n "$step_output" ]]; then
                print_step_errors "$step_output"
            fi
        fi
    done

    local end_time total_duration
    end_time=$(date +%s%3N)
    total_duration=$((end_time - start_time))

    # Final output
    if $JSON; then
        print_json_results "${results[@]}" "$total_duration" "$all_passed"
    elif ! $QUIET; then
        print_summary "$total_duration" "$all_passed"
    fi

    $all_passed && exit 0 || exit 1
}

substitute_vars() {
    local cmd="$1"

    # Substitute <scheme> with detected scheme
    if [[ "$cmd" == *"<scheme>"* ]]; then
        local scheme
        scheme=$(detect_xcode_scheme)
        cmd="${cmd//<scheme>/$scheme}"
    fi

    # Substitute <package_manager>
    if [[ "$cmd" == *"<pm>"* ]]; then
        local pm
        pm=$(detect_package_manager)
        cmd="${cmd//<pm>/$pm}"
    fi

    echo "$cmd"
}

adapt_for_staged() {
    local cmd="$1"

    # Get staged files
    local staged_files
    staged_files=$(git diff --cached --name-only 2>/dev/null | tr '\n' ' ')

    if [[ -z "$staged_files" ]]; then
        echo "true"  # No staged files, pass
        return
    fi

    # Adapt command based on tool
    case "$cmd" in
        *eslint*)
            echo "${cmd} ${staged_files}"
            ;;
        *ruff*)
            echo "${cmd} ${staged_files}"
            ;;
        *swiftlint*)
            echo "swiftlint lint ${staged_files}"
            ;;
        *)
            echo "$cmd"
            ;;
    esac
}

--------------------------------------------------------------------------------

OUTPUT LIBRARY (lib/output.sh):
-------------------------------
# Colors
setup_colors() {
    if [[ -t 1 ]] && [[ -z "${NO_COLOR:-}" ]]; then
        RED='\033[0;31m'
        GREEN='\033[0;32m'
        YELLOW='\033[0;33m'
        BLUE='\033[0;34m'
        CYAN='\033[0;36m'
        BOLD='\033[1m'
        DIM='\033[2m'
        RESET='\033[0m'
    else
        RED='' GREEN='' YELLOW='' BLUE='' CYAN='' BOLD='' DIM='' RESET=''
    fi
}

print_step_result() {
    local name="$1"
    local exit_code="$2"
    local duration_ms="$3"

    local duration_s
    duration_s=$(printf "%.1f" "$(echo "scale=1; $duration_ms / 1000" | bc)")

    if [[ $exit_code -eq 0 ]]; then
        printf "[${DIM}%5ss${RESET}] ${GREEN}✅${RESET} %s\n" "$duration_s" "$name"
    else
        printf "[${DIM}%5ss${RESET}] ${RED}❌${RESET} %s\n" "$duration_s" "$name"
    fi
}

print_step_errors() {
    local output="$1"

    # Indent and dim the error output
    echo "$output" | head -10 | while IFS= read -r line; do
        printf "     ${DIM}%s${RESET}\n" "$line"
    done

    local total_lines
    total_lines=$(echo "$output" | wc -l)
    if [[ $total_lines -gt 10 ]]; then
        printf "     ${DIM}... and %d more lines${RESET}\n" "$((total_lines - 10))"
    fi
}

print_summary() {
    local duration_ms="$1"
    local passed="$2"

    local duration_s
    duration_s=$(printf "%.1f" "$(echo "scale=1; $duration_ms / 1000" | bc)")

    echo "─────────────────────────────"
    if [[ "$passed" == "true" ]]; then
        printf "Total: ${BOLD}%ss${RESET} ${GREEN}✅ All checks passed${RESET}\n" "$duration_s"
    else
        printf "Total: ${BOLD}%ss${RESET} ${RED}❌ Some checks failed${RESET}\n" "$duration_s"
    fi
}

print_json_results() {
    local results=("${@:1:$#-2}")
    local duration="${@: -2:1}"
    local passed="${@: -1}"

    cat << EOF
{
  "success": $passed,
  "duration_ms": $duration,
  "steps": [
    $(IFS=,; echo "${results[*]}")
  ]
}
EOF
}

--------------------------------------------------------------------------------

WATCH LIBRARY (lib/watch.sh):
-----------------------------
run_watch_mode() {
    local project_name
    project_name=$(basename "$(pwd)")

    # Check for fswatch
    if ! command -v fswatch &>/dev/null; then
        die "Watch mode requires fswatch. Install with: brew install fswatch"
    fi

    # Print header
    print_watch_header "$project_name"

    # Initial run
    run_verification || true

    # Watch for changes
    fswatch -o . --exclude '\.git' --exclude 'node_modules' --exclude 'build' | while read -r _; do
        clear_watch_status
        QUICK=true run_verification || true
        print_watch_status
    done
}

print_watch_header() {
    local name="$1"

    cat << EOF
┌─────────────────────────────────────────────────────────────────┐
│ VERIFY WATCH: $name
│ [Enter] Full verify | [Q] Quit | [F] Fix mode
└─────────────────────────────────────────────────────────────────┘
EOF
}

--------------------------------------------------------------------------------

PIPELINE DEFINITIONS (pipelines/typescript.yaml):
-------------------------------------------------
name: typescript
description: TypeScript/Node.js verification pipeline

steps:
  - name: lint
    command: <pm> run lint 2>/dev/null || npx eslint . --max-warnings 0
    fix_command: <pm> run lint:fix 2>/dev/null || npx eslint . --fix
    timeout: 60
    quick: true

  - name: types
    command: <pm> run typecheck 2>/dev/null || npx tsc --noEmit
    timeout: 120
    quick: true

  - name: build
    command: <pm> run build
    timeout: 300
    quick: false

  - name: test
    command: <pm> test
    timeout: 600
    quick: false

--------------------------------------------------------------------------------

PIPELINE DEFINITIONS (pipelines/swift.yaml):
--------------------------------------------
name: swift
description: Swift/Xcode verification pipeline

steps:
  - name: lint
    command: swiftlint lint --quiet
    fix_command: swiftlint lint --fix --quiet
    timeout: 30
    quick: true

  - name: types
    command: swift build 2>&1 | grep -E "error:|warning:" || true
    timeout: 120
    quick: true

  - name: build
    command: xcodebuild build -scheme <scheme> -destination 'platform=iOS Simulator,name=iPhone 15' -quiet
    timeout: 300
    quick: false

  - name: test
    command: xcodebuild test -scheme <scheme> -destination 'platform=iOS Simulator,name=iPhone 15' -quiet
    timeout: 600
    quick: false

--------------------------------------------------------------------------------

PIPELINE DEFINITIONS (pipelines/python.yaml):
---------------------------------------------
name: python
description: Python verification pipeline

steps:
  - name: lint
    command: ruff check .
    fix_command: ruff check . --fix
    timeout: 30
    quick: true

  - name: types
    command: mypy . --ignore-missing-imports
    timeout: 120
    quick: true

  - name: test
    command: pytest -q
    timeout: 600
    quick: false

--------------------------------------------------------------------------------

PIPELINE DEFINITIONS (pipelines/rust.yaml):
-------------------------------------------
name: rust
description: Rust verification pipeline

steps:
  - name: lint
    command: cargo clippy -- -D warnings
    fix_command: cargo clippy --fix --allow-dirty
    timeout: 120
    quick: true

  - name: types
    command: cargo check
    timeout: 120
    quick: true

  - name: build
    command: cargo build
    timeout: 300
    quick: false

  - name: test
    command: cargo test
    timeout: 600
    quick: false

--------------------------------------------------------------------------------

PIPELINE DEFINITIONS (pipelines/go.yaml):
-----------------------------------------
name: go
description: Go verification pipeline

steps:
  - name: lint
    command: go vet ./...
    timeout: 60
    quick: true

  - name: build
    command: go build ./...
    timeout: 120
    quick: true

  - name: test
    command: go test ./... -v
    timeout: 600
    quick: false

================================================================================
                              INSTALLATION
================================================================================

install.sh:
#!/usr/bin/env bash
set -euo pipefail

PREFIX="${PREFIX:-$HOME/.local}"
BIN_DIR="${PREFIX}/bin"
LIB_DIR="${PREFIX}/lib/claude-os/verify"
PIPELINES_DIR="${LIB_DIR}/pipelines"
CONFIG_DIR="${XDG_CONFIG_HOME:-$HOME/.config}/claude-os/verify"

echo "Installing verify CLI..."

mkdir -p "$BIN_DIR" "$LIB_DIR" "$PIPELINES_DIR" "$CONFIG_DIR"

cp bin/verify "$BIN_DIR/"
chmod +x "$BIN_DIR/verify"

cp lib/*.sh "$LIB_DIR/"
cp pipelines/*.yaml "$PIPELINES_DIR/"

# Create default config
if [[ ! -f "$CONFIG_DIR/config.yaml" ]]; then
    cat > "$CONFIG_DIR/config.yaml" << 'EOF'
default_timeout: 600
show_output: errors_only
color: true
EOF
fi

echo "Installation complete!"

================================================================================
                              BUILD CHECKLIST
================================================================================

[ ] Create directory structure
[ ] Implement lib/common.sh
[ ] Implement lib/detect.sh with project/tool detection
[ ] Implement lib/runner.sh with step execution
[ ] Implement lib/output.sh with formatting
[ ] Implement lib/watch.sh with watch mode
[ ] Create bin/verify main executable
[ ] Create all pipeline YAML files
[ ] Create install.sh
[ ] Write tests
[ ] Write README.txt
[ ] Test on Swift, TypeScript, Python, Rust, Go projects

================================================================================
                              START BUILDING
================================================================================

Create all files in the verify/ directory. The tool should:
- Auto-detect project type reliably
- Run verification in < 10s for quick mode
- Provide clear, colored output
- Support all major project types

================================================================================
