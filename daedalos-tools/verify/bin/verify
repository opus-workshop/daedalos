#!/usr/bin/env bash
#===============================================================================
#     ____   ____    ____     ____   ______   ____  __
#    |_  _| |_  _| .'    `.  |_  _| |_    _| |_  _||  |
#      | |    | | |  .--.  |   | |    |  |     | |_/ /
#      \ \  / /  |  |  |  |   | |    |  |     |  __'.
#       \ \/ /   |  `--'  |  _| |_  _|  |_   _| |  \ \_
#        \__/     `.____.'  |_____||_____| |____||____|
#
#                 Universal Project Verification
#===============================================================================

set -euo pipefail

#-------------------------------------------------------------------------------
# Script Location & Library Loading
#-------------------------------------------------------------------------------

# Resolve symlinks to get the real script location
SCRIPT_PATH="${BASH_SOURCE[0]}"
while [[ -L "$SCRIPT_PATH" ]]; do
    SCRIPT_DIR="$(cd "$(dirname "$SCRIPT_PATH")" && pwd)"
    SCRIPT_PATH="$(readlink "$SCRIPT_PATH")"
    [[ "$SCRIPT_PATH" != /* ]] && SCRIPT_PATH="$SCRIPT_DIR/$SCRIPT_PATH"
done
SCRIPT_DIR="$(cd "$(dirname "$SCRIPT_PATH")" && pwd)"
LIB_DIR="${SCRIPT_DIR}/../lib"
PIPELINES_DIR="${SCRIPT_DIR}/../pipelines"

# Export for library functions
export PIPELINES_DIR

# Load library files
source "${LIB_DIR}/common.sh"
source "${LIB_DIR}/output.sh"
source "${LIB_DIR}/detect.sh"
source "${LIB_DIR}/runner.sh"
source "${LIB_DIR}/watch.sh"

#-------------------------------------------------------------------------------
# Command Line Parsing
#-------------------------------------------------------------------------------

# Defaults
QUICK=false
STAGED=false
WATCH=false
FIX=false
JSON=false
QUIET=false
VERBOSE=false
DEBUG=false
PIPELINE=""
ONLY_STEP=""
SKIP_STEPS=()
TARGET_PATH="."

parse_args() {
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -q|--quick)
                QUICK=true
                shift
                ;;
            --staged)
                STAGED=true
                shift
                ;;
            -w|--watch)
                WATCH=true
                shift
                ;;
            --fix)
                FIX=true
                shift
                ;;
            --pipeline)
                PIPELINE="$2"
                shift 2
                ;;
            --step)
                ONLY_STEP="$2"
                shift 2
                ;;
            --skip)
                SKIP_STEPS+=("$2")
                shift 2
                ;;
            --json)
                JSON=true
                shift
                ;;
            --quiet)
                QUIET=true
                shift
                ;;
            -v|--verbose)
                VERBOSE=true
                shift
                ;;
            --debug)
                DEBUG=true
                VERBOSE=true
                shift
                ;;
            -h|--help)
                show_help
                exit 0
                ;;
            --version)
                echo "verify $VERIFY_VERSION"
                exit 0
                ;;
            status)
                cmd_status
                exit 0
                ;;
            pipelines)
                cmd_pipelines
                exit 0
                ;;
            init)
                cmd_init
                exit 0
                ;;
            -*)
                die "Unknown option: $1"
                ;;
            *)
                TARGET_PATH="$1"
                shift
                ;;
        esac
    done
}

#-------------------------------------------------------------------------------
# Commands
#-------------------------------------------------------------------------------

cmd_status() {
    local project_type
    project_type=$(detect_project_type)

    if [[ "$project_type" == "unknown" ]]; then
        echo "Could not detect project type"
        return 1
    fi

    local pipeline_file
    pipeline_file=$(load_pipeline "$project_type" 2>/dev/null || echo "")

    # Get last status
    local last_status
    last_status=$(load_verification_status)

    local last_run="never"
    local last_result="unknown"

    if [[ "$last_status" != "{}" ]]; then
        last_run=$(echo "$last_status" | jq -r '.timestamp // "never"' 2>/dev/null || echo "never")
        local passed
        passed=$(echo "$last_status" | jq -r '.passed // "unknown"' 2>/dev/null || echo "unknown")
        if [[ "$passed" == "true" ]]; then
            last_result="passed"
        elif [[ "$passed" == "false" ]]; then
            last_result="failed"
        fi
    fi

    print_status "$project_type" "$pipeline_file" "$last_run" "$last_result"
}

cmd_pipelines() {
    print_pipelines "$PIPELINES_DIR"
}

cmd_init() {
    local config_dir=".daedalos"
    local config_file="${config_dir}/verify.yaml"

    if [[ -f "$config_file" ]]; then
        echo "Config already exists: $config_file"
        return 1
    fi

    # Detect project type
    local project_type
    project_type=$(detect_project_type)

    mkdir -p "$config_dir"

    cat > "$config_file" << EOF
# verify configuration
# Generated for: $project_type

# Override pipeline (optional)
# pipeline: $project_type

# Custom steps (optional)
# steps:
#   - name: lint
#     command: your-lint-command
#     quick: true
#
#   - name: test
#     command: your-test-command
#     timeout: 300
EOF

    echo "Created $config_file"
    echo "Edit this file to customize verification for your project."
}

#-------------------------------------------------------------------------------
# Main
#-------------------------------------------------------------------------------

main() {
    parse_args "$@"

    # Change to target directory if specified
    if [[ "$TARGET_PATH" != "." ]]; then
        if [[ ! -d "$TARGET_PATH" ]]; then
            die "Not a directory: $TARGET_PATH"
        fi
        cd "$TARGET_PATH"
    fi

    # Export settings for library functions
    export QUICK STAGED FIX JSON QUIET VERBOSE DEBUG PIPELINE ONLY_STEP
    export SKIP_STEPS

    # Run appropriate mode
    if [[ "$WATCH" == "true" ]]; then
        run_watch_mode
    else
        run_verification
        exit $?
    fi
}

main "$@"
