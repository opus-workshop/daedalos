#!/usr/bin/env bash
# session - Save/restore terminal sessions for Daedalos
#
# Capture and restore your complete terminal state.

set -eo pipefail

SESSION_VERSION="1.0.0"

# Data directories
DATA_DIR="${XDG_DATA_HOME:-$HOME/.local/share}/daedalos/session"
SESSIONS_DIR="$DATA_DIR/sessions"

mkdir -p "$SESSIONS_DIR"

# Colors
if [[ -t 1 ]]; then
    RED='\033[0;31m'
    GREEN='\033[0;32m'
    YELLOW='\033[0;33m'
    BLUE='\033[0;34m'
    CYAN='\033[0;36m'
    BOLD='\033[1m'
    DIM='\033[2m'
    NC='\033[0m'
else
    RED='' GREEN='' YELLOW='' BLUE='' CYAN='' BOLD='' DIM='' NC=''
fi

log_error() { echo -e "${RED}error:${NC} $*" >&2; }
log_success() { echo -e "${GREEN}âœ“${NC} $*"; }
log_info() { echo -e "${BLUE}info:${NC} $*"; }

cmd_help() {
    cat << 'EOF'
session - Save/restore terminal sessions for Daedalos

USAGE:
    session <command> [args...]

COMMANDS:
    save [NAME]      Save current session state
    restore [NAME]   Restore a saved session
    list             List saved sessions
    show [NAME]      Show session details
    delete [NAME]    Delete a saved session
    auto             Toggle auto-save on exit
    export [NAME]    Export session to shareable format
    import <FILE>    Import session from file

WHAT'S SAVED:
    - Current working directory
    - Environment variables (filtered)
    - Shell history (recent)
    - Open files in editor (if supported)
    - Git branch and status
    - Running background jobs
    - Tmux/screen layout (if applicable)
    - Daedalos project context

EXAMPLES:
    session save "feature-work"    # Save current state
    session restore "feature-work" # Restore state
    session list                   # Show all sessions
    session auto                   # Toggle auto-save

INTEGRATION:
    Sessions integrate with:
    - env: Restores project environment
    - agent: Restores agent context
    - journal: Logs session switches

EOF
}

# Generate unique session ID
generate_id() {
    date +%Y%m%d_%H%M%S
}

# Get current session state
capture_state() {
    local session_dir="$1"

    mkdir -p "$session_dir"

    # Basic info
    cat > "$session_dir/info.json" << EOF
{
    "created": $(date +%s),
    "cwd": "$PWD",
    "user": "$USER",
    "hostname": "$(hostname)",
    "shell": "$SHELL"
}
EOF

    # Working directory
    echo "$PWD" > "$session_dir/cwd"

    # Environment variables (filtered - exclude secrets)
    env | grep -v -E '(PASSWORD|SECRET|TOKEN|KEY|CREDENTIAL|AUTH)' | sort > "$session_dir/env"

    # Daedalos-specific environment
    env | grep "^DAEDALOS" > "$session_dir/daedalos_env" 2>/dev/null || true

    # Recent shell history
    if [[ -f "$HISTFILE" ]]; then
        tail -n 100 "$HISTFILE" > "$session_dir/history" 2>/dev/null || true
    elif [[ -f "$HOME/.bash_history" ]]; then
        tail -n 100 "$HOME/.bash_history" > "$session_dir/history" 2>/dev/null || true
    elif [[ -f "$HOME/.zsh_history" ]]; then
        tail -n 100 "$HOME/.zsh_history" > "$session_dir/history" 2>/dev/null || true
    fi

    # Git state
    if git rev-parse --git-dir &>/dev/null; then
        cat > "$session_dir/git.json" << EOF
{
    "root": "$(git rev-parse --show-toplevel)",
    "branch": "$(git branch --show-current)",
    "commit": "$(git rev-parse HEAD)",
    "status": "$(git status --porcelain | wc -l | tr -d ' ') modified"
}
EOF
    fi

    # Tmux state
    if [[ -n "$TMUX" ]]; then
        tmux list-windows -F '#{window_index}:#{window_name}:#{pane_current_path}' > "$session_dir/tmux_windows" 2>/dev/null || true
        tmux list-panes -F '#{pane_index}:#{pane_current_path}:#{pane_current_command}' > "$session_dir/tmux_panes" 2>/dev/null || true
    fi

    # Background jobs
    jobs -l > "$session_dir/jobs" 2>/dev/null || true

    # Open files (try to detect from common editors)
    if command -v lsof &>/dev/null; then
        lsof -c vim -c nvim -c code -c emacs 2>/dev/null | grep -E "REG.*$(pwd)" | awk '{print $9}' | sort -u > "$session_dir/open_files" 2>/dev/null || true
    fi
}

# Restore session state
restore_state() {
    local session_dir="$1"
    local dry_run="${2:-false}"

    if [[ ! -d "$session_dir" ]]; then
        log_error "Session not found: $session_dir"
        return 1
    fi

    # Read session info
    local cwd=$(cat "$session_dir/cwd" 2>/dev/null)

    if [[ "$dry_run" == "true" ]]; then
        echo -e "${BOLD}Would restore:${NC}"
        echo -e "  ${CYAN}Directory:${NC} $cwd"

        if [[ -f "$session_dir/git.json" ]]; then
            local branch=$(grep '"branch"' "$session_dir/git.json" | cut -d'"' -f4)
            echo -e "  ${CYAN}Git branch:${NC} $branch"
        fi

        if [[ -f "$session_dir/daedalos_env" ]]; then
            echo -e "  ${CYAN}Daedalos env:${NC}"
            sed 's/^/    /' "$session_dir/daedalos_env"
        fi
        return
    fi

    # Generate restore script
    local restore_script=""

    # Change directory
    if [[ -d "$cwd" ]]; then
        restore_script="cd '$cwd'"
    fi

    # Restore Daedalos environment variables
    if [[ -f "$session_dir/daedalos_env" ]]; then
        while IFS='=' read -r key value; do
            restore_script="$restore_script && export $key='$value'"
        done < "$session_dir/daedalos_env"
    fi

    # If project has environment, source it
    if [[ -f "$cwd/.daedalos/env.sh" ]]; then
        restore_script="$restore_script && source '$cwd/.daedalos/env.sh'"
    fi

    echo -e "${BOLD}To restore this session, run:${NC}"
    echo ""
    echo "  $restore_script"
    echo ""

    # Optional: Restore git branch
    if [[ -f "$session_dir/git.json" ]]; then
        local branch=$(grep '"branch"' "$session_dir/git.json" | cut -d'"' -f4)
        echo -e "${DIM}Git branch was: $branch${NC}"
        echo -e "${DIM}To switch: git checkout $branch${NC}"
    fi
}

cmd_save() {
    local name="${1:-$(generate_id)}"
    local session_dir="$SESSIONS_DIR/$name"

    if [[ -d "$session_dir" ]]; then
        log_info "Overwriting existing session: $name"
        rm -rf "$session_dir"
    fi

    capture_state "$session_dir"

    # Save name
    echo "$name" > "$session_dir/name"

    log_success "Session saved: $name"
    echo -e "${DIM}Restore with: session restore $name${NC}"

    # Log to journal
    if command -v journal &>/dev/null; then
        journal log "Session saved: $name in $PWD" "session" "session_save" 2>/dev/null || true
    fi
}

cmd_restore() {
    local name="$1"
    local dry_run=false

    if [[ "$name" == "--dry-run" ]] || [[ "$name" == "-n" ]]; then
        dry_run=true
        name="$2"
    fi

    if [[ -z "$name" ]]; then
        # List recent sessions and prompt
        echo -e "${BOLD}Recent sessions:${NC}"
        ls -t "$SESSIONS_DIR" 2>/dev/null | head -5 | while read -r session; do
            local info_file="$SESSIONS_DIR/$session/info.json"
            if [[ -f "$info_file" ]]; then
                local cwd=$(cat "$SESSIONS_DIR/$session/cwd" 2>/dev/null)
                echo "  $session - ${cwd:-unknown}"
            fi
        done
        echo ""
        log_error "Session name required"
        return 1
    fi

    local session_dir="$SESSIONS_DIR/$name"

    if [[ ! -d "$session_dir" ]]; then
        log_error "Session not found: $name"
        echo "Use 'session list' to see available sessions"
        return 1
    fi

    restore_state "$session_dir" "$dry_run"

    # Log to journal
    if [[ "$dry_run" == "false" ]] && command -v journal &>/dev/null; then
        journal log "Session restored: $name" "session" "session_restore" 2>/dev/null || true
    fi
}

cmd_list() {
    local as_json=false
    [[ "$1" == "--json" ]] && as_json=true

    if [[ ! -d "$SESSIONS_DIR" ]] || [[ -z "$(ls -A "$SESSIONS_DIR" 2>/dev/null)" ]]; then
        if [[ "$as_json" == "true" ]]; then
            echo "[]"
        else
            echo "No saved sessions"
        fi
        return
    fi

    if [[ "$as_json" == "true" ]]; then
        echo "["
        local first=true
        for session_dir in "$SESSIONS_DIR"/*; do
            [[ -d "$session_dir" ]] || continue
            local name=$(basename "$session_dir")
            local cwd=$(cat "$session_dir/cwd" 2>/dev/null)
            local created=$(grep '"created"' "$session_dir/info.json" 2>/dev/null | grep -o '[0-9]*')

            [[ "$first" == "true" ]] || echo ","
            first=false

            echo "  {\"name\": \"$name\", \"cwd\": \"$cwd\", \"created\": $created}"
        done
        echo "]"
        return
    fi

    echo -e "${BOLD}Saved Sessions${NC}"
    echo ""

    for session_dir in $(ls -dt "$SESSIONS_DIR"/* 2>/dev/null); do
        [[ -d "$session_dir" ]] || continue

        local name=$(basename "$session_dir")
        local cwd=$(cat "$session_dir/cwd" 2>/dev/null)
        local created=$(grep '"created"' "$session_dir/info.json" 2>/dev/null | grep -o '[0-9]*')
        local date_str=""

        if [[ -n "$created" ]]; then
            date_str=$(date -r "$created" "+%Y-%m-%d %H:%M" 2>/dev/null || date -d "@$created" "+%Y-%m-%d %H:%M" 2>/dev/null)
        fi

        echo -e "  ${CYAN}$name${NC}"
        echo -e "    ${DIM}Path:${NC} $cwd"
        [[ -n "$date_str" ]] && echo -e "    ${DIM}Saved:${NC} $date_str"

        # Show git branch if available
        if [[ -f "$session_dir/git.json" ]]; then
            local branch=$(grep '"branch"' "$session_dir/git.json" 2>/dev/null | cut -d'"' -f4)
            [[ -n "$branch" ]] && echo -e "    ${DIM}Branch:${NC} $branch"
        fi
        echo ""
    done
}

cmd_show() {
    local name="$1"

    if [[ -z "$name" ]]; then
        log_error "Session name required"
        return 1
    fi

    local session_dir="$SESSIONS_DIR/$name"

    if [[ ! -d "$session_dir" ]]; then
        log_error "Session not found: $name"
        return 1
    fi

    echo -e "${BOLD}Session: $name${NC}"
    echo ""

    # Basic info
    if [[ -f "$session_dir/info.json" ]]; then
        echo -e "${CYAN}Info:${NC}"
        cat "$session_dir/info.json" | sed 's/^/  /'
        echo ""
    fi

    # Git state
    if [[ -f "$session_dir/git.json" ]]; then
        echo -e "${CYAN}Git:${NC}"
        cat "$session_dir/git.json" | sed 's/^/  /'
        echo ""
    fi

    # Daedalos environment
    if [[ -f "$session_dir/daedalos_env" ]] && [[ -s "$session_dir/daedalos_env" ]]; then
        echo -e "${CYAN}Daedalos Environment:${NC}"
        sed 's/^/  /' "$session_dir/daedalos_env"
        echo ""
    fi

    # Open files
    if [[ -f "$session_dir/open_files" ]] && [[ -s "$session_dir/open_files" ]]; then
        echo -e "${CYAN}Open Files:${NC}"
        sed 's/^/  /' "$session_dir/open_files"
        echo ""
    fi

    # Recent history
    if [[ -f "$session_dir/history" ]]; then
        echo -e "${CYAN}Recent Commands (last 10):${NC}"
        tail -n 10 "$session_dir/history" | sed 's/^/  /'
        echo ""
    fi
}

cmd_delete() {
    local name="$1"

    if [[ -z "$name" ]]; then
        log_error "Session name required"
        return 1
    fi

    local session_dir="$SESSIONS_DIR/$name"

    if [[ ! -d "$session_dir" ]]; then
        log_error "Session not found: $name"
        return 1
    fi

    rm -rf "$session_dir"
    log_success "Session deleted: $name"
}

cmd_export() {
    local name="${1:-$(ls -t "$SESSIONS_DIR" 2>/dev/null | head -1)}"
    local output="${2:-$name.session.tar.gz}"

    if [[ -z "$name" ]]; then
        log_error "No sessions to export"
        return 1
    fi

    local session_dir="$SESSIONS_DIR/$name"

    if [[ ! -d "$session_dir" ]]; then
        log_error "Session not found: $name"
        return 1
    fi

    tar -czf "$output" -C "$SESSIONS_DIR" "$name"
    log_success "Exported to: $output"
}

cmd_import() {
    local file="$1"

    if [[ -z "$file" ]] || [[ ! -f "$file" ]]; then
        log_error "Session file required"
        return 1
    fi

    tar -xzf "$file" -C "$SESSIONS_DIR"
    log_success "Session imported"
}

cmd_auto() {
    local auto_file="$DATA_DIR/auto_save"

    if [[ -f "$auto_file" ]]; then
        rm -f "$auto_file"
        log_info "Auto-save disabled"
        echo "Sessions will not be saved automatically on exit"
    else
        touch "$auto_file"
        log_success "Auto-save enabled"
        echo "Add this to your shell config to enable:"
        echo ""
        echo '  trap '\''session save "auto_$(date +%Y%m%d_%H%M%S)"'\'' EXIT'
    fi
}

main() {
    local cmd="${1:-help}"

    case "$cmd" in
        help|--help|-h)
            cmd_help
            ;;
        save|s)
            shift
            cmd_save "$@"
            ;;
        restore|r|load)
            shift
            cmd_restore "$@"
            ;;
        list|ls|l)
            shift
            cmd_list "$@"
            ;;
        show)
            shift
            cmd_show "$@"
            ;;
        delete|rm|remove)
            shift
            cmd_delete "$@"
            ;;
        export)
            shift
            cmd_export "$@"
            ;;
        import)
            shift
            cmd_import "$@"
            ;;
        auto)
            cmd_auto
            ;;
        version|--version|-V)
            echo "session $SESSION_VERSION"
            ;;
        *)
            log_error "Unknown command: $cmd"
            echo "Run 'session help' for usage"
            exit 1
            ;;
    esac
}

main "$@"
