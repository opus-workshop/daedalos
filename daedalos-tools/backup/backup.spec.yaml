name: backup
version: 1.0
created: 2025-01-11

intent: |
  Undo is for mistakes. Backup is for disaster.

  The undo tool handles "I just broke this file." Backup handles
  "My disk died" or "I need yesterday's version" or "Let me snapshot
  before this risky refactor." Different scope, different purpose.

  The deeper insight: AI agents can't perceive time passing. An agent
  doesn't know that it's been three days since the last backup. It
  doesn't feel the slow dread of "I should probably back this up."
  Automated backups remove temporal awareness from the equation.

  Backup is insurance you hope to never use. But when you need it -
  hard drive failure, accidental rm -rf, ransomware - it's the difference
  between "annoying day" and "catastrophic loss."

  Human equivalent: "I want to freeze this project's state RIGHT NOW,
  with the option to jump back to it weeks or months later."

constraints:
  - No external dependencies for basic backup (tar is enough)
  - Optional encryption (age) and compression (gzip)
  - Git bundles for git projects (includes full history)
  - Smart excludes by default (node_modules, .venv, build artifacts)
  - Prune old backups to prevent disk exhaustion
  - Export/import for offline backup storage
  - Metadata stored alongside backups (JSON, human-readable)
  - Works without network (local backups first)

interface:
  commands:
    create:
      args: "[PATH] [--name NAME] [--full|--incremental|--git] [--compress] [--encrypt] [--exclude PATTERN] [--remote HOST]"
      returns: "Creates backup archive with metadata"
      example: "backup create --name 'pre-refactor'"

    restore:
      args: "<BACKUP> [TARGET] [--force]"
      returns: "Restores backup to target location"
      example: "backup restore myproject-20240115"

    list:
      args: "[--project NAME] [--json]"
      returns: "Available backups with details"
      example: "backup list --project myproject"

    show:
      args: "<BACKUP>"
      returns: "Detailed metadata for specific backup"
      example: "backup show myproject-20240115"

    delete:
      args: "<BACKUP> [--force]"
      returns: "Removes backup files"
      example: "backup delete old-backup --force"

    prune:
      args: "[--keep N] [--project NAME] [--dry-run]"
      returns: "Removes old backups, keeps N most recent"
      example: "backup prune --keep 10"

    export:
      args: "<BACKUP> [OUTPUT]"
      returns: "Copies backup to specified location"
      example: "backup export myproject-20240115 /mnt/usb/"

    import:
      args: "<FILE>"
      returns: "Imports backup from external location"
      example: "backup import /mnt/usb/myproject-20240115.tar.gz"

    schedule:
      args: "[--daily|--hourly|--on-commit|--disable]"
      returns: "Configures automatic backups"
      example: "backup schedule --on-commit"

  options:
    name: "--name NAME: Custom backup name (default: project-timestamp)"
    full: "--full: Full backup (default)"
    incremental: "--incremental: Only changed files since last backup"
    git: "--git: Git bundle backup (includes history)"
    compress: "--compress: Compress with gzip (default: true)"
    encrypt: "--encrypt: Encrypt with age"
    exclude: "--exclude PATTERN: Additional exclude pattern"
    remote: "--remote HOST: Copy backup to remote host"
    keep: "--keep N: Number of backups to retain in prune"
    force: "--force: Skip confirmations"

  exit_codes:
    0: "Success"
    1: "Backup not found or invalid"
    2: "Restore failed"
    3: "Encryption/decryption error"
    4: "Insufficient disk space"

examples:
  - scenario: "Pre-refactor insurance"
    context: "About to restructure entire codebase"
    action: "backup create --name 'before-big-refactor'"
    result: "Named backup created, can restore if refactor goes wrong"
    why_it_matters: |
      Refactors can go sideways. Multiple commits, hard to revert.
      A backup is a clean snapshot to return to. Git history is
      fine-grained; sometimes you want the coarse grain of "just
      take me back to yesterday."

  - scenario: "Automated daily backups"
    context: "Important project, want protection without thinking"
    action: "backup schedule --daily"
    result: "Cron job created for midnight backups"
    why_it_matters: |
      Humans forget to backup. Schedules don't. The best backup
      strategy is one that runs without human intervention.

  - scenario: "Git project with full history"
    context: "Need portable backup including all branches and commits"
    action: "backup create --git"
    result: "Git bundle created (includes complete history)"
    why_it_matters: |
      Tar doesn't preserve git history properly. A git bundle is
      a single file containing the entire repository. Clone from
      bundle to get everything back.

  - scenario: "Encrypted backup for sensitive project"
    context: "Project contains API keys, customer data"
    action: "backup create --encrypt"
    result: "Backup encrypted with age before storage"
    why_it_matters: |
      Backups are copies of your data. If data is sensitive,
      backups must be encrypted. Stolen backup = stolen secrets.

  - scenario: "Disk space management"
    context: "Backups accumulating, disk filling up"
    action: "backup prune --keep 10"
    result: "Keeps 10 most recent, deletes older backups per project"
    why_it_matters: |
      Backups without pruning = disk exhaustion. Prune balances
      safety (keep some) with practicality (don't keep all).

  - scenario: "Offsite backup to USB"
    context: "Want backup that survives house fire"
    action: |
      backup create
      backup export myproject-20240115 /mnt/usb/
    result: "Backup created and copied to external drive"
    why_it_matters: |
      Local backups protect against mistakes. Offsite backups
      protect against disasters. USB drive in another location
      is simple offsite backup.

decisions:
  - choice: "Tar for archives, git bundles for git repos"
    why: |
      Two backup types serve different needs:

      Tar archives:
      - Work for any directory
      - Include everything (files, symlinks, permissions)
      - No git dependency

      Git bundles:
      - Full repository history
      - All branches and tags
      - Clone-able (not just extract-able)

      --git flag chooses bundle; default is tar.
      For git repos, bundles are better but tars work too.
    alternatives:
      - option: "Tar only"
        rejected_because: "Loses git history, can't clone from backup"
      - option: "Git bundle only"
        rejected_because: "Doesn't work for non-git directories"
      - option: "Zip files"
        rejected_because: "Worse compression, doesn't preserve Unix permissions"

  - choice: "Smart default excludes"
    why: |
      Every project has junk that shouldn't be backed up:
      - node_modules (regenerate from package.json)
      - .venv (regenerate from requirements.txt)
      - target, dist, build (rebuild from source)
      - __pycache__, *.pyc (bytecode, regenerate)
      - .git (excluded in tar, separate in bundle)

      Excluding these makes backups smaller and faster.
      Users can override with --exclude for custom patterns.
    alternatives:
      - option: "No default excludes"
        rejected_because: "Backups bloated with regeneratable files"
      - option: "Require explicit excludes"
        rejected_because: "Every backup needs same excludes, tedious"
      - option: "Use .gitignore"
        rejected_because: ".gitignore is for git, backup excludes may differ"

  - choice: "Compression on by default"
    why: |
      Text-heavy projects (code) compress dramatically.
      A 100MB project might compress to 10MB.

      Storage space saved, transfer time reduced.
      Modern CPUs handle gzip with negligible delay.

      --no-compress available if raw speed matters more than space.
    alternatives:
      - option: "No compression by default"
        rejected_because: "Wastes space for minimal time savings"
      - option: "Better compression (zstd, xz)"
        rejected_because: "gzip is universally available, good enough"

  - choice: "age for encryption"
    why: |
      age is the modern replacement for GPG:
      - Simple (no key management complexity)
      - Secure (audited, modern cryptography)
      - Unix philosophy (does one thing well)

      Integration with secrets tool for key storage.
      Encrypted backups are safe to store in cloud/offsite.
    alternatives:
      - option: "GPG"
        rejected_because: "Complex key management, confusing UX"
      - option: "OpenSSL enc"
        rejected_because: "Foot-guns, easy to misuse"
      - option: "No encryption"
        rejected_because: "Sensitive data in backups is common"

  - choice: "Prune by project, keep N most recent"
    why: |
      Different projects have different backup frequencies.
      Pruning globally would unfairly remove less-backed-up projects.

      Per-project pruning: each project keeps its N most recent.
      This ensures all projects have recovery points.

      --keep N is simple to understand and predictable.
    alternatives:
      - option: "Global keep N"
        rejected_because: "Active project crowds out other projects' backups"
      - option: "Time-based (keep 30 days)"
        rejected_because: "Project backed up daily loses all if not touched for 30 days"
      - option: "Size-based pruning"
        rejected_because: "Hard to predict, might prune important backups"

  - choice: "Metadata in JSON sidecar files"
    why: |
      Each backup has .meta.json with:
      - Original project name and path
      - Timestamp (Unix and ISO)
      - Backup type (full, git)
      - Size
      - Encryption status

      JSON is human-readable, script-parseable.
      Sidecar file means metadata survives even if archive is encrypted.
    alternatives:
      - option: "Metadata inside archive"
        rejected_because: "Can't read metadata without extracting"
      - option: "SQLite database"
        rejected_because: "Harder to inspect, doesn't travel with backup"
      - option: "Filename encodes metadata"
        rejected_because: "Limited info, ugly filenames"

anti_patterns:
  - pattern: "Backup as version control"
    why_bad: |
      "I'll just backup after each change" - no, use git.
      Backups are coarse-grained snapshots. Git is for tracking changes.

      Backup: disaster recovery, milestone snapshots
      Git: history, collaboration, code review

  - pattern: "Never pruning backups"
    why_bad: |
      Backups accumulate. Each one takes space.
      A year of daily backups = 365 backups per project.

      Schedule pruning or disk fills eventually.
      "backup prune --keep 30" in cron alongside backup creation.

  - pattern: "Encrypted backup without testing restore"
    why_bad: |
      Encryption adds failure modes. Wrong key = unrecoverable.

      ALWAYS test restore after creating encrypted backup.
      A backup you can't restore is worse than no backup
      (false sense of security).

  - pattern: "Backing up to same disk"
    why_bad: |
      Default backup location is on the same drive.
      Drive failure = lose both original AND backups.

      Use --remote or export to external storage.
      The point of backup is surviving hardware failure.

  - pattern: "Including secrets in backup without encryption"
    why_bad: |
      .env files, credentials.json, API keys...
      If these are in your project, backup copies them.

      Either exclude them (--exclude .env) or encrypt the backup.
      Unencrypted backup with secrets = security incident waiting.

connects_to:
  - component: undo
    relationship: |
      Different scales of protection:

      undo: File-level, seconds-to-hours, fast restore
      backup: Project-level, days-to-months, full recovery

      undo for "I just broke this file"
      backup for "I need last week's version" or "disk died"

      They complement, not compete.

  - component: remote
    relationship: |
      Backup can push to remote hosts:
      backup create --remote offsite-server

      Uses remote tool for the transfer.
      Offsite backups survive local disasters.

  - component: secrets
    relationship: |
      Encrypted backups use age, which can integrate with secrets vault.
      The encryption key can be stored in secrets.

      backup create --encrypt -> uses secrets key for encryption
      backup restore -> uses secrets key for decryption

  - component: git
    relationship: |
      Git bundles are git-aware backups:
      - Include all branches and tags
      - Include complete history
      - Clone-able, not just extractable

      For git repos, --git flag creates bundles instead of tars.

  - component: journal
    relationship: |
      Backup logs operations:
      "Created backup: myproject-20240115 (10M)"

      Audit trail of when backups were created and restored.
      Useful for compliance and debugging.

  - component: schedule (cron)
    relationship: |
      backup schedule creates cron entries:
      - --daily: midnight
      - --hourly: every hour
      - --on-commit: git hook

      Automated backups remove human forgetfulness from the equation.

metrics:
  success_criteria:
    - "Backup creation completes in < 30 seconds for typical project (100MB)"
    - "Restore recovers exact project state"
    - "Encrypted backups decrypt correctly with correct key"
    - "Prune correctly identifies and removes old backups"
    - "Smart excludes reduce backup size by 50%+ for typical projects"

  failure_indicators:
    - "Backups too large (excludes not working)"
    - "Restore fails (archive corruption, encryption issues)"
    - "Prune removes wanted backups"
    - "Disk fills up (prune not scheduled)"
    - "Users don't backup (process too manual)"
