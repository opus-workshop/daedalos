================================================================================
                           ERROR-DB - SPECIFICATION
                          Error Pattern Database
================================================================================

VERSION: 1.0.0
LICENSE: MIT
AUTHOR: Claude (Opus)
STATUS: Reference Specification

================================================================================
                                 PHILOSOPHY
================================================================================

"Learn once, fix forever."

Every error message is a lesson. But lessons are useless if forgotten.

Error-DB captures error patterns and their solutions:
  1. When you encounter an error, check if it's known
  2. If known, get the fix instantly
  3. If unknown, record the solution for next time
  4. Share knowledge across projects and teams

This is institutional memory for debugging.

================================================================================
                               CORE CONCEPTS
================================================================================

ERROR PATTERN
-------------
A recognizable error signature that can match similar errors.
Patterns use fuzzy matching to catch variations of the same error.

Example pattern:
  "Cannot find module 'X'"  matches  "Cannot find module 'lodash'"

SOLUTION
--------
A verified fix for an error pattern. Can include:
  - Text explanation
  - Code changes
  - Commands to run
  - Links to documentation

CONFIDENCE
----------
How reliable a solution is, based on:
  - Number of times it's worked
  - Recency of confirmation
  - User ratings

SCOPE
-----
Where an error pattern applies:
  - Global: Universal errors (e.g., "ENOENT: no such file")
  - Language: Language-specific (e.g., "IndentationError")
  - Framework: Framework-specific (e.g., "React Hook rules")
  - Project: Project-specific errors

================================================================================
                              COMMAND INTERFACE
================================================================================

error-db search <error-text>
----------------------------
Search for a matching error pattern and get solutions.

Arguments:
  <error-text>        The error message (can be multiline)

Options:
  --stdin             Read error from stdin (for piping)
  --json              Output as JSON
  --all               Show all matches (not just best)
  --scope <scope>     Limit to scope: global|language|framework|project

Examples:
  error-db search "Cannot find module 'lodash'"
  npm test 2>&1 | error-db search --stdin
  error-db search "TypeError: Cannot read property 'map' of undefined"

Output:
  ╭─────────────────────────────────────────────────────────────────────╮
  │ PATTERN MATCH (95% confidence)                                      │
  │ Cannot find module 'X'                                              │
  ├─────────────────────────────────────────────────────────────────────┤
  │ SOLUTION                                                            │
  │                                                                     │
  │ The module is not installed. Run:                                   │
  │                                                                     │
  │   npm install lodash                                                │
  │                                                                     │
  │ Or if it's a type definition:                                       │
  │                                                                     │
  │   npm install --save-dev @types/lodash                             │
  │                                                                     │
  ├─────────────────────────────────────────────────────────────────────┤
  │ ✓ Worked 847 times  │  Last confirmed: 2 hours ago                 │
  ╰─────────────────────────────────────────────────────────────────────╯

error-db add
------------
Add a new error pattern and solution.

Interactive mode guides you through:
  1. Enter the error pattern
  2. Enter the solution
  3. Set scope and tags
  4. Optionally test the solution

Options:
  --pattern <pat>     Error pattern (with X for variables)
  --solution <sol>    Solution text
  --scope <scope>     Scope: global|language|framework|project
  --tags <tags>       Comma-separated tags
  --command <cmd>     Command to fix (for auto-fix feature)

Examples:
  error-db add --pattern "ECONNREFUSED X:Y" \
               --solution "Service not running. Start with: docker-compose up" \
               --scope global

error-db confirm <pattern-id>
-----------------------------
Confirm that a solution worked.
Increases confidence score.

error-db report <pattern-id>
----------------------------
Report that a solution didn't work.
Decreases confidence score.

error-db fix <error-text>
-------------------------
Search and auto-apply fix if available.

If the solution includes a command, offers to run it:
  Found solution: "npm install lodash"
  Run this command? [Y/n]

Options:
  --yes               Auto-confirm command execution
  --dry-run           Show what would be done

error-db list [--scope <scope>]
-------------------------------
List known error patterns.

Options:
  --scope <scope>     Filter by scope
  --language <lang>   Filter by language
  --tag <tag>         Filter by tag
  --recent            Sort by recent additions
  --popular           Sort by usage count

error-db show <pattern-id>
--------------------------
Show detailed information about an error pattern.

Output includes:
  - Full pattern
  - All solutions (ranked by confidence)
  - Usage statistics
  - Related patterns
  - Source (who added it)

error-db edit <pattern-id>
--------------------------
Edit an existing pattern or solution.

error-db delete <pattern-id>
----------------------------
Delete a pattern (requires confirmation).

error-db import <file>
----------------------
Import patterns from file (JSON or YAML).

error-db export [--scope <scope>]
---------------------------------
Export patterns for sharing.

Options:
  --format <fmt>      Format: json|yaml
  --scope <scope>     Export specific scope

error-db sync
-------------
Sync with community error database.

Options:
  --pull              Pull new patterns from community
  --push              Contribute local patterns to community
  --url <url>         Custom sync server

error-db stats
--------------
Show database statistics.

Output:
  Total patterns: 1,247
  By scope:
    - Global: 523
    - Language: 412
    - Framework: 198
    - Project: 114

  By language:
    - JavaScript/TypeScript: 387
    - Python: 245
    - Rust: 156
    - Go: 89

  Top contributors: ...
  Most used patterns: ...

================================================================================
                              PATTERN SYNTAX
================================================================================

Patterns use a simple syntax for matching:

VARIABLES
---------
X, Y, Z match any text:
  "Cannot find module 'X'"  →  matches "Cannot find module 'anything'"

REGEX
-----
/regex/ for complex patterns:
  "/error: E\d{4}/"  →  matches "error: E0001", "error: E0532", etc.

MULTILINE
---------
Patterns can span multiple lines:
  """
  Error: X
    at Y (Z)
  """

FUZZY
-----
By default, patterns use fuzzy matching:
  - Ignores whitespace variations
  - Handles line number differences
  - Normalizes paths

================================================================================
                              DATA STORAGE
================================================================================

Local database: ~/.local/share/daedalos/error-db/errors.db

Schema:
```sql
CREATE TABLE patterns (
    id TEXT PRIMARY KEY,
    pattern TEXT NOT NULL,
    scope TEXT NOT NULL,
    language TEXT,
    framework TEXT,
    tags TEXT,
    created_at TIMESTAMP,
    updated_at TIMESTAMP
);

CREATE TABLE solutions (
    id TEXT PRIMARY KEY,
    pattern_id TEXT REFERENCES patterns(id),
    solution TEXT NOT NULL,
    command TEXT,
    confidence REAL DEFAULT 0.5,
    success_count INTEGER DEFAULT 0,
    failure_count INTEGER DEFAULT 0,
    created_at TIMESTAMP,
    last_confirmed TIMESTAMP
);

CREATE TABLE usage_log (
    id INTEGER PRIMARY KEY,
    pattern_id TEXT,
    solution_id TEXT,
    outcome TEXT,  -- 'success' | 'failure' | 'skipped'
    timestamp TIMESTAMP
);
```

================================================================================
                         INTEGRATION WITH AGENTS
================================================================================

Agents can query error-db automatically:

```bash
# In agent prompt
"When you encounter an error, first check: error-db search '<error>'"

# Auto-fix integration
make build 2>&1 | error-db fix --stdin --yes
```

Loop integration:
```bash
# Loop can auto-check errors
loop start "fix build" --promise "make build" \
  --on-error "error-db search --stdin"
```

================================================================================
                         COMMUNITY SHARING
================================================================================

Patterns can be shared via:

1. DAEDALOS COMMUNITY HUB
   Default sync server at errors.daedalos.dev (once established)
   Anonymous contribution with attribution option

2. GIT REPOSITORY
   Export patterns to git repo for team sharing:
     error-db export --scope project > .daedalos/errors.yaml
     # Commit and push

3. IMPORT FROM URL
   error-db import https://raw.githubusercontent.com/.../errors.yaml

================================================================================
                              EXIT CODES
================================================================================

0   Success / Pattern found
1   General error
2   No matching pattern found
3   Database error
4   Sync failed
5   Invalid pattern syntax

================================================================================
                           IMPLEMENTATION NOTES
================================================================================

Language: Python

Dependencies:
  - Python 3.10+
  - sqlite3 (bundled)
  - rapidfuzz (fuzzy matching)
  - rich (terminal UI)
  - pyyaml
  - httpx (for sync)

Architecture:
  - SQLite for local storage
  - Fuzzy matching with rapidfuzz
  - Simple HTTP API for community sync
  - CLI with rich formatting

================================================================================
