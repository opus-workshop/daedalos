name: error-db
version: 1.0
created: 2025-01-11

intent: |
  Agents solve the same errors repeatedly. Every session starts fresh.

  Error-DB is institutional memory for debugging. When an agent hits
  "Cannot find module 'X'", it shouldn't rediscover the fix - it should
  instantly know "run npm install X".

  The key insight: debugging knowledge is transferable. An error solved
  once should stay solved forever. Agents shouldn't think - they should
  remember.

  This compresses debugging cycles from minutes to milliseconds.

constraints:
  - Pattern matching must be fuzzy (handle path/line variations)
  - Database must be local-first (works offline)
  - Sub-second search on pattern match
  - No external dependencies for core functionality (beyond Python stdlib)
  - Supports import/export for team sharing
  - Confidence scoring based on success/failure tracking

interface:
  commands:
    search:
      args: "<error-text> [--stdin] [--json] [--all]"
      returns: "Best matching pattern with solution, confidence score"
      example: "error-db search 'Cannot find module lodash'"

    add:
      args: "--pattern <pat> --solution <sol> [--scope global|language|project]"
      returns: "Confirmation of pattern addition"
      example: "error-db add --pattern 'ECONNREFUSED' --solution 'Start docker'"

    fix:
      args: "<error-text> [--yes] [--dry-run]"
      returns: "Searches and optionally executes fix command"
      example: "npm test 2>&1 | error-db fix --stdin --yes"

    confirm:
      args: "<pattern-id>"
      returns: "Increases confidence score for solution"
      example: "error-db confirm err-123"

    report:
      args: "<pattern-id>"
      returns: "Decreases confidence score, marks solution unreliable"
      example: "error-db report err-123"

    list:
      args: "[--scope] [--language] [--popular]"
      returns: "Known error patterns with usage stats"
      example: "error-db list --language python"

    import:
      args: "<file>"
      returns: "Imports patterns from YAML/JSON file"
      example: "error-db import team-errors.yaml"

    export:
      args: "[--scope] [--format json|yaml]"
      returns: "Exports patterns for sharing"
      example: "error-db export --scope project > errors.yaml"

  exit_codes:
    0: success / pattern found
    1: general error
    2: no matching pattern found
    3: database error
    5: invalid pattern syntax

examples:
  - scenario: "Agent hits common error"
    context: "Build fails with 'Cannot find module lodash'"
    action: "error-db search 'Cannot find module lodash'"
    result: |
      Pattern match (95% confidence)
      Solution: npm install lodash
      Worked 847 times, last confirmed 2 hours ago
    why_it_matters: "Instant fix, no debugging, no Stack Overflow"

  - scenario: "Loop auto-diagnoses failures"
    context: "Loop running with --on-error hook"
    action: "make build 2>&1 | error-db search --stdin"
    result: "Error automatically identified with solution injected into loop"
    why_it_matters: "Loop becomes self-healing for known errors"

  - scenario: "Recording a new solution"
    context: "Solved a rare error after 20 minutes of debugging"
    action: "error-db add --pattern 'SSL_ERROR_RX_RECORD' --solution 'Export NODE_TLS_REJECT_UNAUTHORIZED=0'"
    result: "Pattern saved, next time anyone hits it: instant fix"
    why_it_matters: "Debugging effort preserved, not wasted"

  - scenario: "Team knowledge sharing"
    context: "Project has specific errors only team knows"
    action: "error-db export --scope project > .daedalos/errors.yaml && git add ."
    result: "Project errors checked into repo, new team members get them"
    why_it_matters: "Debugging knowledge travels with code"

decisions:
  - choice: "Fuzzy matching with rapidfuzz"
    why: |
      Exact matching fails for most errors:
      - Line numbers change
      - Paths differ between machines
      - Whitespace varies

      Fuzzy matching (rapidfuzz) handles these gracefully.
      Pattern variables (X, Y, Z) match any text for structured matching.
    alternatives:
      - option: "Regex only"
        rejected_because: "Hard to write, brittle, overkill for most patterns"
      - option: "Exact string match"
        rejected_because: "Fails on line number variations, paths, etc."

  - choice: "SQLite with confidence scoring"
    why: |
      Confidence = (success_count + 1) / (success_count + failure_count + 2)

      Bayesian smoothing prevents early solutions from being too confident.
      Every confirm() increases confidence, every report() decreases it.

      Bad solutions naturally decay. Good solutions rise to top.
    alternatives:
      - option: "Simple file-based storage"
        rejected_because: "No efficient querying, no atomic updates"
      - option: "Manual curation only"
        rejected_because: "Doesn't scale, stale solutions persist"

  - choice: "Scopes: global → language → framework → project"
    why: |
      Errors have natural hierarchies:
      - ENOENT is global (any system)
      - IndentationError is Python
      - React Hooks rules are React
      - "MyService not found" is project-specific

      Scopes enable precise matching and prevent pollution.
      Project scope stays in project. Global scope ships with tool.

  - choice: "Optional auto-fix with confirmation"
    why: |
      Sometimes the fix is a command (npm install, docker-compose up).
      error-db fix can offer to run it with [Y/n] prompt.

      --yes flag for automation (loop integration).
      Default is safe: show but don't run.

anti_patterns:
  - pattern: "Storing raw error output as pattern"
    why_bad: |
      Raw output includes machine-specific paths, timestamps, line numbers.
      These will never match again. Extract the stable signature only.

  - pattern: "No confidence tracking"
    why_bad: |
      Old or wrong solutions persist forever. Confidence scoring lets
      bad solutions decay naturally when reported.

  - pattern: "Requiring internet for basic functionality"
    why_bad: |
      Debugging happens offline, on planes, in restricted environments.
      Core functionality must be local-first. Sync is optional enhancement.

  - pattern: "One solution per pattern"
    why_bad: |
      Same error can have multiple valid fixes depending on context.
      Store multiple solutions, rank by confidence, let user choose.

  - pattern: "Verbose pattern descriptions"
    why_bad: |
      Pattern should be minimal signature, not documentation.
      Solution text has the explanation. Pattern is just for matching.

connects_to:
  - component: loop
    relationship: |
      Loop's --on-error hook can pipe to error-db search.
      When loop iteration fails, error-db suggests fix.
      Loop can auto-apply if confidence > 90%.

  - component: verify
    relationship: |
      When verify fails, pipe output to error-db.
      Common verification errors (test failures, lint errors) can have
      solutions like "run npm run lint -- --fix".

  - component: agent
    relationship: |
      Agents should check error-db before attempting to debug.
      Instruction: "When hitting an error, first: error-db search '<error>'"
      This prevents wasted thinking on known issues.

  - component: codex
    relationship: |
      Codex can search for error handling code.
      Error-db tells you HOW to fix. Codex shows you WHERE it's handled.
      Together they provide complete error understanding.

metrics:
  success_criteria:
    - "error-db search returns in < 200ms"
    - "Pattern match accuracy > 90% on known errors"
    - "Agents check error-db before debugging (habit formed)"
    - "Zero repeat debugging sessions for known errors"

  failure_indicators:
    - "Agents rediscovering known fixes"
    - "Database full of stale/wrong solutions"
    - "Patterns too specific to ever match again"
    - "Users not adding solutions after debugging"
