name: daedalos
version: 1.0
created: 2025-01-11

intent: |
  One command. All tools. Zero friction.

  The daedalos command exists because fragmentation kills adoption.
  Twenty separate tools means twenty things to remember, twenty different
  invocations, twenty entries in PATH. Users forget what's available.
  New users don't know where to start.

  The daedalos command is the front door. It says: "start here."
  Everything is reachable from this single point. Tab completion shows
  what's available. Help shows the philosophy. Status shows what's running.

  The deeper insight: a tool suite is only as good as its discoverability.
  Powerful tools hidden behind obscure names are wasted. daedalos surfaces
  everything: the tools, their purpose, their status, their health.

  This is the CLI equivalent of a well-designed home screen. You see
  what's there, what's active, what needs attention. The system becomes
  comprehensible at a glance.

constraints:
  - Must dispatch to any tool in < 50ms (thin wrapper)
  - Help must show philosophy, not just flags
  - Tab completion for all tools and subcommands
  - Works if some tools are missing (graceful degradation)
  - Status shows daemon health without requiring daemons
  - No external dependencies beyond bash and standard utils

interface:
  commands:
    dispatch:
      args: "<tool> [args...]"
      returns: "Executes the specified Daedalos tool"
      example: "daedalos loop start 'fix tests' --promise pytest"

    help:
      args: ""
      returns: "Philosophy, tool overview, quick start examples"
      example: "daedalos help"

    tools:
      args: "[--json]"
      returns: "List all tools with installation status"
      example: "daedalos tools"

    status:
      args: ""
      returns: "Daemon health, active loops, active agents"
      example: "daedalos status"

    doctor:
      args: ""
      returns: "Installation verification and diagnostics"
      example: "daedalos doctor"

    version:
      args: ""
      returns: "Version info for daedalos and installed tools"
      example: "daedalos version"

    install-completions:
      args: "[bash|zsh]"
      returns: "Installs shell completions"
      example: "daedalos install-completions zsh"

  exit_codes:
    0: "Success (or dispatched tool's exit code)"
    1: "Tool not installed or unknown command"
    2: "Installation issue detected"

examples:
  - scenario: "New user exploring"
    context: "Just installed Daedalos, doesn't know where to start"
    action: "daedalos"
    result: "Beautiful help with ASCII art, philosophy, all tools listed"
    why_it_matters: |
      First impression matters. The help isn't a dry man page - it's
      an introduction to a philosophy. Users understand WHY, not just WHAT.

  - scenario: "Running a tool"
    context: "User wants to run semantic search"
    action: "daedalos codex search 'authentication'"
    result: "Dispatches to codex with all arguments"
    why_it_matters: |
      Thin wrapper. No overhead. User could run 'codex' directly,
      but 'daedalos codex' provides discoverability and consistency.

  - scenario: "Checking what's running"
    context: "Multiple things happening, need overview"
    action: "daedalos status"
    result: "Shows daemon health, active loops, active agents"
    why_it_matters: |
      Quick health check without launching observe TUI.
      Terminal-friendly, scriptable output.

  - scenario: "Diagnosing issues"
    context: "Something not working, not sure what"
    action: "daedalos doctor"
    result: "Checks tools, dependencies, directories, reports issues"
    why_it_matters: |
      Self-diagnostic. User doesn't have to guess what's missing.
      Clear report of what's installed, what's not, how to fix.

  - scenario: "Setting up shell"
    context: "Want tab completion for all tools"
    action: "daedalos install-completions"
    result: "Completion files installed, instructions shown"
    why_it_matters: |
      Completions are critical for discoverability. This command
      removes the friction of manual setup.

decisions:
  - choice: "exec dispatch, not subprocess"
    why: |
      daedalos codex â†’ exec codex (replaces process)

      This means:
      - No overhead (no extra bash process)
      - Exit codes propagate correctly
      - Signals handled by the tool, not wrapper
      - Memory efficient

      Subprocess would add latency and complicate signal handling.
    alternatives:
      - option: "Subprocess with output capture"
        rejected_because: "Overhead, complicates streaming output"
      - option: "Source tools instead of exec"
        rejected_because: "Pollutes environment, unexpected side effects"

  - choice: "Help shows philosophy prominently"
    why: |
      Most --help is boring: "usage: tool [flags]"

      Daedalos help starts with:
      - ASCII art (memorable branding)
      - Philosophy statement
      - THE CORE section (loop is special)
      - Categorized tools with descriptions

      This educates, not just documents.
    alternatives:
      - option: "Standard man-page style help"
        rejected_because: "Boring, doesn't convey philosophy"
      - option: "Minimal help, full docs online"
        rejected_because: "Friction, works offline is a constraint"

  - choice: "Graceful degradation for missing tools"
    why: |
      User might install only some tools. daedalos should:
      - Show missing tools dimmed in 'daedalos tools'
      - Explain tool not installed if invoked
      - Suggest 'daedalos doctor' for diagnostics

      Complete failure because one tool is missing would be hostile.
    alternatives:
      - option: "Fail if any tool missing"
        rejected_because: "Too strict, partial installation is valid"
      - option: "Silently ignore missing tools"
        rejected_because: "User should know what's not available"

  - choice: "Status without daemon dependency"
    why: |
      'daedalos status' should work even if all daemons are down.

      It checks socket existence, process existence, queries tools
      directly. Never requires a daemon to respond to show status.

      If loopd is crashed, status should say "stopped", not crash.
    alternatives:
      - option: "Query daemon for all status"
        rejected_because: "Fails if daemon down, circular dependency"
      - option: "Only show daemon-less tools"
        rejected_because: "Loses valuable information"

  - choice: "Completions as separate command, not auto-install"
    why: |
      Shell configuration is personal. Some users have complex
      setups with custom completion systems.

      install-completions is opt-in:
      - Shows what it will do
      - Tells user what to add to their rc file
      - User maintains control

      Auto-modifying shell rc files would be presumptuous.
    alternatives:
      - option: "Auto-install completions on first run"
        rejected_because: "Modifying user's shell config without asking"
      - option: "No completion support"
        rejected_because: "Major discoverability loss"

anti_patterns:
  - pattern: "Using 'daedalos' prefix when not needed"
    why_bad: |
      'daedalos loop start' works, but 'loop start' is shorter.
      The daedalos prefix is for discoverability, not required.

      Power users will use the direct commands.
      New users can use daedalos prefix until comfortable.

  - pattern: "Expecting daedalos to add features to tools"
    why_bad: |
      daedalos is a dispatcher, not an enhancer.
      'daedalos loop start' does exactly what 'loop start' does.

      No magic, no hidden behavior, no surprises.

  - pattern: "Running 'daedalos status' in scripts expecting structured output"
    why_bad: |
      Status is human-friendly, not machine-friendly.
      For scripts, use the individual tools:
        loop list --json
        agent list --json

      Status is for humans at the terminal.

  - pattern: "Ignoring doctor output"
    why_bad: |
      If doctor reports issues, fix them. Partial installations
      cause confusing errors later.

      Doctor is the first thing to run when something's wrong.

connects_to:
  - component: all-tools
    relationship: |
      daedalos dispatches to every Daedalos tool.
      It's the umbrella command that unifies the suite.

      Tool discovery: daedalos tools
      Tool invocation: daedalos <tool> [args]

  - component: observe
    relationship: |
      daedalos status gives quick text overview.
      observe gives full TUI dashboard.

      Status for quick checks, observe for monitoring.

  - component: spec
    relationship: |
      daedalos could potentially show spec info:
        daedalos spec loop

      This would make specs discoverable through the main command.
      (Not implemented yet, but natural extension.)

  - component: kitty
    relationship: |
      Kitty integration binds daedalos tools to keyboard shortcuts.
      ctrl+shift+d calls daedalos status.

      The daedalos command is the CLI interface,
      kitty shortcuts are the GUI-ish interface.

metrics:
  success_criteria:
    - "New users find daedalos help useful (not just comprehensive)"
    - "Tool dispatch adds < 50ms latency"
    - "Tab completion works for all tools and subcommands"
    - "daedalos doctor identifies real issues"
    - "Users can navigate the tool suite without reading docs"

  failure_indicators:
    - "Users forget daedalos exists and call tools directly only"
    - "Help is too long, users don't read it"
    - "Status is slow or crashes when daemons down"
    - "Doctor misses actual installation issues"
    - "Users get confused about what's a tool vs meta-command"
