#!/usr/bin/env bash
# agent - Multi-agent orchestration for Daedalos
#
# Manages multiple Claude Code instances running in tmux sessions.
# Part of the Daedalos toolsuite.

set -euo pipefail

AGENT_VERSION="1.0.0"

# Get the real path, following symlinks
SCRIPT_PATH="${BASH_SOURCE[0]}"
while [[ -L "$SCRIPT_PATH" ]]; do
    SCRIPT_DIR="$(cd "$(dirname "$SCRIPT_PATH")" && pwd)"
    SCRIPT_PATH="$(readlink "$SCRIPT_PATH")"
    [[ "$SCRIPT_PATH" != /* ]] && SCRIPT_PATH="$SCRIPT_DIR/$SCRIPT_PATH"
done
SCRIPT_DIR="$(cd "$(dirname "$SCRIPT_PATH")" && pwd)"
LIB_DIR="${SCRIPT_DIR}/../lib"

# Source library files
source "${LIB_DIR}/common.sh"
source "${LIB_DIR}/tmux.sh"
source "${LIB_DIR}/agents.sh"
source "${LIB_DIR}/status.sh"
source "${LIB_DIR}/search.sh"
source "${LIB_DIR}/templates.sh"
source "${LIB_DIR}/snapshot.sh"
source "${LIB_DIR}/comms.sh"
source "${LIB_DIR}/signals.sh"
source "${LIB_DIR}/hooks.sh"
source "${LIB_DIR}/workflow.sh"
source "${LIB_DIR}/groups.sh"

# Check requirements on startup
check_requirements

# Command: list
cmd_list() {
    local as_json=false
    local quiet=false

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --json) as_json=true; shift ;;
            --quiet|-q) quiet=true; shift ;;
            *) die "Unknown option: $1" ;;
        esac
    done

    format_agent_list "$as_json" "$quiet"
}

# Command: spawn
cmd_spawn() {
    local name=""
    local project=""
    local template=""
    local sandbox=""
    local no_focus=false
    local initial_prompt=""

    while [[ $# -gt 0 ]]; do
        case "$1" in
            -n|--name) name="$2"; shift 2 ;;
            -p|--project) project="$2"; shift 2 ;;
            -t|--template) template="$2"; shift 2 ;;
            -s|--sandbox) sandbox="$2"; shift 2 ;;
            --no-focus|--background) no_focus=true; shift ;;
            --prompt) initial_prompt="$2"; shift 2 ;;
            *) die "Unknown option: $1" ;;
        esac
    done

    # Default project to current directory
    if [[ -z "$project" ]]; then
        project="$(pwd)"
    fi
    project="$(cd "$project" && pwd)"  # Resolve to absolute path

    # Generate name if not provided
    if [[ -z "$name" ]]; then
        local base_name
        base_name=$(basename "$project")
        local counter=1
        name="${base_name}"
        while agents_exists "$name"; do
            name="${base_name}-${counter}"
            ((counter++))
        done
    fi

    # Validate name
    validate_name "$name"

    # Check if agent already exists
    if agents_exists "$name"; then
        die "Agent already exists: $name"
    fi

    # Check agent limit
    if agents_at_limit; then
        die "Maximum number of agents reached"
    fi

    # Get next slot
    local slot
    slot=$(agents_next_slot) || die "No available slots"

    # Apply template if specified
    if [[ -n "$template" ]]; then
        if ! templates_exists "$template"; then
            die "Template not found: $template"
        fi
        if [[ -z "$sandbox" ]]; then
            sandbox=$(templates_get_sandbox "$template")
        fi
    fi

    # Default sandbox
    sandbox="${sandbox:-implement}"

    # Build claude command
    local -a claude_cmd=("claude")

    # Add template args
    if [[ -n "$template" ]]; then
        local template_args
        template_args=$(templates_get_claude_args "$template")
        if [[ -n "$template_args" ]]; then
            read -ra args <<< "$template_args"
            claude_cmd+=("${args[@]}")
        fi
    fi

    # Create tmux session
    local session
    session=$(tmux_session_name "$name")

    info "Spawning agent: $name (slot $slot)"
    debug "Project: $project"
    debug "Session: $session"
    debug "Command: ${claude_cmd[*]}"

    # Set up environment
    if [[ -n "$template" ]]; then
        while IFS='=' read -r key value; do
            [[ -n "$key" ]] && export "$key=$value"
        done < <(templates_get_env "$template")
    fi

    # Create tmux session
    if ! tmux_create_session "$session" "$project" "${claude_cmd[@]}"; then
        die "Failed to create tmux session"
    fi

    # Record agent in database
    agents_create "$name" "$project" "${template:-default}" "$sandbox" "$slot"

    # Set slot env var
    tmux_set_slot "$session" "$slot"

    # Get PID and update
    sleep 0.5
    local pid
    pid=$(tmux_get_pane_pid "$session")
    if [[ -n "$pid" ]]; then
        agents_set_pid "$name" "$pid"
    fi

    # Clear any previous completion signal
    signal_clear "$name"

    # Send initial prompt if provided
    if [[ -n "$initial_prompt" ]]; then
        sleep 1
        # Build prompt with template's system prompt and prefix
        local full_prompt
        if [[ -n "$template" ]]; then
            full_prompt=$(templates_build_prompt "$template" "$initial_prompt")
        else
            full_prompt="$initial_prompt"
        fi
        tmux_send_keys "$session" "$full_prompt" Enter
    fi

    success "Agent spawned: $name (slot $slot)"

    # Run on_spawn hooks
    hooks_on_spawn "$name" "$template" "$project"

    # Focus unless told not to
    if [[ "$no_focus" != "true" ]]; then
        if [[ "$(config_get auto_focus true)" == "true" ]]; then
            tmux_focus_session "$session"
        fi
    fi
}

# Command: focus
cmd_focus() {
    if [[ $# -eq 0 ]]; then
        # Interactive selection with fzf if available
        if has_fzf; then
            local selected
            selected=$(agents_names | fzf --prompt="Select agent: ")
            if [[ -z "$selected" ]]; then
                return
            fi
            cmd_focus "$selected"
            return
        fi
        die "Usage: agent focus <name|slot>"
    fi

    local identifier="$1"

    local name
    name=$(agents_resolve "$identifier")
    if [[ -z "$name" ]]; then
        die "Agent not found: $identifier"
    fi

    local agent
    agent=$(agents_get "$name")
    local session
    session=$(echo "$agent" | jq -r '.tmux_session')

    if ! tmux_session_exists "$session"; then
        die "Session does not exist for agent: $name"
    fi

    tmux_focus_session "$session"
}

# Command: status
cmd_status() {
    local name=""
    local as_json=false
    local watch=false
    local interval=2

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --json) as_json=true; shift ;;
            --watch|-w) watch=true; shift ;;
            --interval|-i) interval="$2"; shift 2 ;;
            -*) die "Unknown option: $1" ;;
            *) name="$1"; shift ;;
        esac
    done

    if [[ "$watch" == "true" ]]; then
        watch_status "$name" "$interval"
        return
    fi

    if [[ -n "$name" ]]; then
        local resolved
        resolved=$(agents_resolve "$name")
        if [[ -z "$resolved" ]]; then
            die "Agent not found: $name"
        fi
        format_agent_status "$resolved" "$as_json"
    else
        format_agent_list "$as_json"
    fi
}

# Command: kill
cmd_kill() {
    local force=false
    local all=false
    local names=()

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --force|-f) force=true; shift ;;
            --all|-a) all=true; shift ;;
            -*) die "Unknown option: $1" ;;
            *) names+=("$1"); shift ;;
        esac
    done

    if [[ "$all" == "true" ]]; then
        # Confirmation for killing all
        echo "This will kill all agents."
        read -rp "Are you sure? (y/N) " confirm
        if [[ "$confirm" != "y" && "$confirm" != "Y" ]]; then
            echo "Aborted."
            return
        fi

        while IFS= read -r name; do
            [[ -z "$name" ]] && continue
            kill_agent "$name" "$force"
        done < <(agents_names)
        return
    fi

    if [[ ${#names[@]} -eq 0 ]]; then
        die "Usage: agent kill <name|slot> or agent kill --all"
    fi

    for identifier in "${names[@]}"; do
        local name
        name=$(agents_resolve "$identifier")
        if [[ -z "$name" ]]; then
            warn "Agent not found: $identifier"
            continue
        fi
        kill_agent "$name" "$force"
    done
}

# Helper: Kill a single agent
kill_agent() {
    local name="$1"
    local force="${2:-false}"

    local agent
    agent=$(agents_get "$name")
    if [[ -z "$agent" ]]; then
        return
    fi

    local session
    session=$(echo "$agent" | jq -r '.tmux_session')

    info "Killing agent: $name"

    # Kill tmux session
    tmux_kill_session "$session" "$force"

    # Remove from database
    agents_delete "$name"

    success "Agent killed: $name"
}

# Command: logs
cmd_logs() {
    local name=""
    local follow=true
    local lines=100

    while [[ $# -gt 0 ]]; do
        case "$1" in
            -f|--follow) follow=true; shift ;;
            --no-follow) follow=false; shift ;;
            -n) lines="$2"; shift 2 ;;
            -*) die "Unknown option: $1" ;;
            *) name="$1"; shift ;;
        esac
    done

    if [[ -z "$name" ]]; then
        die "Usage: agent logs <name|slot>"
    fi

    local resolved
    resolved=$(agents_resolve "$name")
    if [[ -z "$resolved" ]]; then
        die "Agent not found: $name"
    fi

    local agent
    agent=$(agents_get "$resolved")
    local session
    session=$(echo "$agent" | jq -r '.tmux_session')

    if ! tmux_session_exists "$session"; then
        die "Session does not exist for agent: $resolved"
    fi

    if [[ "$follow" == "true" ]]; then
        # Follow logs using tmux capture-pane in a loop
        while true; do
            clear
            echo "${C_BOLD}Logs: ${C_CYAN}${resolved}${C_RESET} (Ctrl+C to exit)"
            echo ""
            tmux_get_pane_content "$session" "$lines"
            sleep 1
        done
    else
        tmux_get_pane_content "$session" "$lines"
    fi
}

# Command: search
cmd_search() {
    local query=""
    local agent=""
    local ignore_case=false
    local context=2
    local as_json=false
    local interactive=false

    while [[ $# -gt 0 ]]; do
        case "$1" in
            -a|--agent) agent="$2"; shift 2 ;;
            -i|--ignore-case) ignore_case=true; shift ;;
            -c|--context) context="$2"; shift 2 ;;
            --json) as_json=true; shift ;;
            --interactive) interactive=true; shift ;;
            -*) die "Unknown option: $1" ;;
            *) query="$1"; shift ;;
        esac
    done

    if [[ "$interactive" == "true" ]]; then
        search_interactive "$query"
        return
    fi

    if [[ -z "$query" ]]; then
        die "Usage: agent search <query>"
    fi

    search_all "$query" "$agent" "$ignore_case" "$context" "$as_json"
}

# Command: pause
cmd_pause() {
    if [[ $# -eq 0 ]]; then
        die "Usage: agent pause <name|slot>"
    fi

    local identifier="$1"
    local name
    name=$(agents_resolve "$identifier")
    if [[ -z "$name" ]]; then
        die "Agent not found: $identifier"
    fi

    local agent
    agent=$(agents_get "$name")
    local session
    session=$(echo "$agent" | jq -r '.tmux_session')

    if ! tmux_session_exists "$session"; then
        die "Session does not exist for agent: $name"
    fi

    if tmux_pause_process "$session"; then
        agents_update "$name" "status" "paused"
        success "Agent paused: $name"
    else
        die "Failed to pause agent: $name"
    fi
}

# Command: resume
cmd_resume() {
    if [[ $# -eq 0 ]]; then
        die "Usage: agent resume <name|slot>"
    fi

    local identifier="$1"
    local name
    name=$(agents_resolve "$identifier")
    if [[ -z "$name" ]]; then
        die "Agent not found: $identifier"
    fi

    local agent
    agent=$(agents_get "$name")
    local session
    session=$(echo "$agent" | jq -r '.tmux_session')

    if ! tmux_session_exists "$session"; then
        die "Session does not exist for agent: $name"
    fi

    if tmux_resume_process "$session"; then
        agents_update "$name" "status" "active"
        success "Agent resumed: $name"
    else
        die "Failed to resume agent: $name"
    fi
}

# Command: snapshot
cmd_snapshot() {
    local action="${1:-create}"

    case "$action" in
        create)
            shift
            snapshot_create "$@"
            ;;
        list|ls)
            shift
            snapshot_list "${1:-false}"
            ;;
        show)
            shift
            snapshot_show "$@"
            ;;
        delete|rm)
            shift
            snapshot_delete "$@"
            ;;
        *)
            # If first arg doesn't look like a subcommand, treat as agent name
            if [[ "$action" != -* ]] && ! [[ "$action" =~ ^(create|list|ls|show|delete|rm)$ ]]; then
                snapshot_create "$@"
            else
                die "Unknown snapshot action: $action"
            fi
            ;;
    esac
}

# Command: restore
cmd_restore() {
    snapshot_restore "$@"
}

# Command: register - register current terminal as an agent
cmd_register() {
    local name=""
    local project=""
    local agent_type="claude-code"

    while [[ $# -gt 0 ]]; do
        case "$1" in
            -n|--name) name="$2"; shift 2 ;;
            -p|--project) project="$2"; shift 2 ;;
            --type) agent_type="$2"; shift 2 ;;
            -*) die "Unknown option: $1" ;;
            *)
                if [[ -z "$name" ]]; then
                    name="$1"
                fi
                shift
                ;;
        esac
    done

    # Default project to current directory
    if [[ -z "$project" ]]; then
        project="$(pwd)"
    fi
    project="$(cd "$project" && pwd)"

    # Generate name if not provided
    if [[ -z "$name" ]]; then
        local base_name
        base_name=$(basename "$project")
        local counter=1
        name="${base_name}"
        while agents_exists "$name"; do
            name="${base_name}-${counter}"
            ((counter++))
        done
    fi

    # Validate name
    validate_name "$name"

    # Check if already registered
    if agents_exists "$name"; then
        die "Agent already exists: $name"
    fi

    # Check slot availability
    if agents_at_limit; then
        die "Agent limit reached. Kill an existing agent first."
    fi

    # Create the external agent entry
    agents_create_external "$name" "$project" "$agent_type"

    # Export environment variables for this session
    export DAEDALOS_AGENT_NAME="$name"
    export DAEDALOS_DATA_DIR="$DATA_DIR"
    export DAEDALOS_MESSAGES_DIR="${DATA_DIR}/messages"
    export DAEDALOS_SHARED_DIR="${DATA_DIR}/shared"

    success "Registered as: $name (slot $(agents_get "$name" | jq -r '.slot'))"
    echo ""
    echo "To use messaging in this shell:"
    echo "  export DAEDALOS_AGENT_NAME=$name"
    echo ""
    echo "Or add to your shell rc file to persist."
}

# Command: unregister - unregister current terminal
cmd_unregister() {
    local name="${1:-${DAEDALOS_AGENT_NAME:-}}"

    if [[ -z "$name" ]]; then
        die "Not registered. Provide agent name or set DAEDALOS_AGENT_NAME."
    fi

    if ! agents_exists "$name"; then
        die "Agent not found: $name"
    fi

    # Only allow unregistering external agents
    if ! agents_is_external "$name"; then
        die "Cannot unregister tmux-managed agent. Use 'agent kill' instead."
    fi

    agents_delete "$name"
    unset DAEDALOS_AGENT_NAME

    success "Unregistered: $name"
}

# Command: whoami - show current agent identity
cmd_whoami() {
    local name
    name=$(agents_whoami) || {
        echo "Not registered as an agent."
        echo ""
        echo "Register with: agent register <name>"
        return 1
    }

    local agent
    agent=$(agents_get "$name")
    local slot project agent_type
    slot=$(echo "$agent" | jq -r '.slot')
    project=$(echo "$agent" | jq -r '.project')
    agent_type=$(echo "$agent" | jq -r '.agent_type // "tmux"')

    echo "${C_BOLD}$name${C_RESET} (slot $slot)"
    echo "  Type: $agent_type"
    echo "  Project: $project"
}

# Command: send - send message to another agent
cmd_send() {
    local to=""
    local msg_type="message"
    local content=""

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --to|-t) to="$2"; shift 2 ;;
            --type) msg_type="$2"; shift 2 ;;
            -*) die "Unknown option: $1" ;;
            *)
                if [[ -z "$to" ]]; then
                    to="$1"
                else
                    content="$1"
                fi
                shift
                ;;
        esac
    done

    if [[ -z "$to" ]] || [[ -z "$content" ]]; then
        die "Usage: agent send <to_agent> <message>"
    fi

    # Auto-register if needed, get identity
    local from
    from=$(agents_ensure_identity) || from="anonymous"

    comms_send "$to" "$from" "$msg_type" "$content"
    success "Message sent to: $to (from: $from)"
}

# Command: inbox - check messages
cmd_inbox() {
    local agent=""
    local all=false
    local as_json=false

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --agent|-a) agent="$2"; shift 2 ;;
            --all) all=true; shift ;;
            --json) as_json=true; shift ;;
            -*) die "Unknown option: $1" ;;
            *) agent="$1"; shift ;;
        esac
    done

    # Auto-register if needed
    if [[ -z "$agent" ]]; then
        agent=$(agents_ensure_identity) || die "Could not determine agent identity. Use: agent inbox <name>"
    fi

    local args=("$agent")
    [[ "$all" == "true" ]] && args+=("--all")
    [[ "$as_json" == "true" ]] && args+=("--json")

    comms_inbox "${args[@]}"
}

# Command: help - request help from another agent
cmd_request_help() {
    local from=""
    local task=""
    local template=""

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --from|-f) from="$2"; shift 2 ;;
            --template|-t) template="$2"; shift 2 ;;
            -*) die "Unknown option: $1" ;;
            *) task="$1"; shift ;;
        esac
    done

    if [[ -z "$task" ]]; then
        die "Usage: agent request-help <task_description>"
    fi

    # Auto-register if needed
    if [[ -z "$from" ]]; then
        from=$(agents_ensure_identity) || from="anonymous"
    fi

    local args=("$from" "$task")
    [[ -n "$template" ]] && args+=("--template" "$template")

    comms_help "${args[@]}"
}

# Command: share - share file with agents
cmd_share() {
    local from=""
    local file=""
    local to=""
    local name=""

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --from|-f) from="$2"; shift 2 ;;
            --to|-t) to="$2"; shift 2 ;;
            --name|-n) name="$2"; shift 2 ;;
            -*) die "Unknown option: $1" ;;
            *) file="$1"; shift ;;
        esac
    done

    if [[ -z "$file" ]]; then
        die "Usage: agent share <file_path>"
    fi

    # Auto-register if needed
    if [[ -z "$from" ]]; then
        from=$(agents_ensure_identity) || from="anonymous"
    fi

    local args=("$from" "$file")
    [[ -n "$to" ]] && args+=("--to" "$to")
    [[ -n "$name" ]] && args+=("--name" "$name")

    comms_share "${args[@]}"
}

# Command: artifacts - list shared artifacts
cmd_artifacts() {
    local as_json=false
    [[ "${1:-}" == "--json" ]] && as_json=true
    comms_artifacts "$as_json"
}

# Command: broadcast - send to all agents
cmd_broadcast() {
    local from=""
    local message=""

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --from|-f) from="$2"; shift 2 ;;
            -*) die "Unknown option: $1" ;;
            *) message="$1"; shift ;;
        esac
    done

    if [[ -z "$message" ]]; then
        die "Usage: agent broadcast <message>"
    fi

    # Auto-register if needed
    if [[ -z "$from" ]]; then
        from=$(agents_ensure_identity) || from="anonymous"
    fi

    comms_broadcast "$from" "$message"
}

# Command: workflow - manage multi-agent workflows
cmd_workflow() {
    local action="${1:-list}"
    shift || true

    case "$action" in
        list|ls)
            workflow_list "${1:-false}"
            ;;
        show)
            workflow_show "$@"
            ;;
        start|run)
            workflow_start "$@"
            ;;
        status)
            workflow_status "$@"
            ;;
        stop)
            workflow_stop "$@"
            ;;
        *)
            # If it looks like a workflow name, try to start it
            if [[ -f "${WORKFLOWS_DIR}/${action}.yaml" ]]; then
                workflow_start "$action" "$@"
            else
                die "Unknown workflow action: $action"
            fi
            ;;
    esac
}

# Command: group - manage agent groups
cmd_group() {
    local action="${1:-list}"
    shift || true

    case "$action" in
        list|ls)
            groups_list "${1:-false}"
            ;;
        create|new)
            if [[ $# -eq 0 ]]; then
                die "Usage: agent group create <name> [description]"
            fi
            groups_create "$@"
            ;;
        delete|rm)
            if [[ $# -eq 0 ]]; then
                die "Usage: agent group delete <name>"
            fi
            groups_delete "$@"
            ;;
        show)
            if [[ $# -eq 0 ]]; then
                die "Usage: agent group show <name>"
            fi
            groups_show "$@"
            ;;
        add)
            if [[ $# -lt 2 ]]; then
                die "Usage: agent group add <group> <agent> [agent...]"
            fi
            groups_add "$@"
            ;;
        remove)
            if [[ $# -lt 2 ]]; then
                die "Usage: agent group remove <group> <agent> [agent...]"
            fi
            groups_remove "$@"
            ;;
        kill)
            if [[ $# -eq 0 ]]; then
                die "Usage: agent group kill <name>"
            fi
            local name="$1"
            local force=false
            [[ "${2:-}" == "--force" ]] && force=true
            groups_kill "$name" "$force"
            ;;
        pause)
            if [[ $# -eq 0 ]]; then
                die "Usage: agent group pause <name>"
            fi
            groups_pause "$1"
            ;;
        resume)
            if [[ $# -eq 0 ]]; then
                die "Usage: agent group resume <name>"
            fi
            groups_resume "$1"
            ;;
        send)
            if [[ $# -lt 2 ]]; then
                die "Usage: agent group send <group> <message>"
            fi
            groups_send "$1" "$2"
            ;;
        team)
            if [[ $# -lt 2 ]]; then
                die "Usage: agent group team <name> <project> [templates...]"
            fi
            groups_spawn_team "$@"
            ;;
        *)
            die "Unknown group action: $action"
            ;;
    esac
}

# Command: templates
cmd_templates() {
    local action="${1:-list}"
    shift || true

    case "$action" in
        list)
            templates_list "${1:-false}"
            ;;
        show)
            if [[ $# -eq 0 ]]; then
                die "Usage: agent templates show <name>"
            fi
            templates_show "$1"
            ;;
        create)
            if [[ $# -eq 0 ]]; then
                die "Usage: agent templates create <name> [description]"
            fi
            templates_create "$@"
            ;;
        delete)
            if [[ $# -eq 0 ]]; then
                die "Usage: agent templates delete <name>"
            fi
            templates_delete "$1"
            ;;
        *)
            die "Unknown templates action: $action"
            ;;
    esac
}

# Show help
show_help() {
    cat << 'EOF'
agent - Multi-agent orchestration for Daedalos

USAGE:
    agent <command> [options]

COMMANDS:
    list                    List all agents
    spawn                   Spawn a new agent
    focus <name|slot>       Focus an agent
    status [name]           Show agent status
    kill <name|slot>        Kill an agent
    logs <name|slot>        Show agent logs
    search <query>          Search across agents
    pause <name|slot>       Pause an agent
    resume <name|slot>      Resume a paused agent
    snapshot                Create/manage snapshots
    restore <snapshot>      Restore agents from snapshot
    templates               Manage templates
    help                    Show this help

SNAPSHOT COMMANDS:
    snapshot [name] --all   Snapshot all agents (or named agent)
    snapshot list           List available snapshots
    snapshot show <name>    Show snapshot details
    snapshot delete <name>  Delete a snapshot
    restore <snapshot>      Restore agents from snapshot

REGISTRATION (for Claude Code terminals, etc.):
    register [name]         Register current terminal as an agent
    unregister [name]       Unregister current terminal
    whoami                  Show current agent identity

COMMUNICATION COMMANDS:
    send <agent> <msg>      Send message to an agent
    inbox <agent>           Check agent's messages
    request-help <task>     Request help (spawns helper if needed)
    share <file>            Share file with other agents
    artifacts               List shared artifacts
    broadcast <msg>         Send message to all agents

WORKFLOW COMMANDS:
    workflow list           List available workflows
    workflow show <name>    Show workflow definition
    workflow start <w> <t>  Start workflow with task
    workflow status [id]    Show workflow status
    workflow stop <id>      Stop a running workflow

BUILT-IN WORKFLOWS:
    feature                 Explorer -> Planner -> Implementer -> Reviewer
    review                  Parallel: Correctness + Security + Style
    bugfix                  Investigate -> Fix -> Verify
    tdd                     Plan -> Test First -> Implement -> Verify
    refactor                Analyze -> Test Baseline -> Refactor -> Verify

GROUP COMMANDS:
    group list              List all groups
    group create <name>     Create a new group
    group show <name>       Show group details
    group add <g> <agent>   Add agent(s) to group
    group remove <g> <a>    Remove agent(s) from group
    group kill <name>       Kill all agents in group
    group pause <name>      Pause all agents in group
    group resume <name>     Resume all agents in group
    group send <g> <msg>    Send message to group
    group team <n> <proj>   Spawn a team with default templates

COORDINATION COMMANDS:
    signal complete         Signal that work is complete
    signal wait <agent>     Wait for agent to complete
    signal check <agent>    Check if agent completed
    lock acquire <name>     Acquire a resource lock
    lock release <name>     Release a resource lock
    lock list               List active locks
    claim create <task>     Claim a task
    claim release <task>    Release a task claim
    claim list              List active claims

LIFECYCLE HOOKS:
    hooks list              List all hooks
    hooks create <e> <n>    Create a new hook for event
    hooks add <e> <script>  Add existing script as hook
    hooks remove <e> <n>    Remove a hook
    hooks enable <e> <n>    Enable a hook
    hooks disable <e> <n>   Disable a hook

HOOK EVENTS:
    on_spawn                Agent created
    on_complete             Agent signaled completion
    on_error                Agent encountered error
    on_kill                 Agent was killed
    on_workflow_complete    Workflow finished

SPAWN OPTIONS:
    -n, --name <name>       Agent name
    -p, --project <path>    Project directory (default: current)
    -t, --template <name>   Use a template
    -s, --sandbox <preset>  Sandbox preset (explore, implement, debug)
    --no-focus              Don't focus the new agent
    --prompt <text>         Initial prompt to send

LIST OPTIONS:
    --json                  Output as JSON
    --quiet                 Only output agent names

STATUS OPTIONS:
    --json                  Output as JSON
    --watch                 Continuously update
    --interval <secs>       Update interval (default: 2)

KILL OPTIONS:
    --force                 Force kill without graceful shutdown
    --all                   Kill all agents

SEARCH OPTIONS:
    -a, --agent <name>      Search only in this agent
    -i, --ignore-case       Case insensitive search
    -c, --context <lines>   Context lines (default: 2)
    --json                  Output as JSON
    --interactive           Interactive search with fzf

TEMPLATES:
    explorer                Read-only exploration and research
    implementer             Full write access for implementation
    reviewer                Code review mode (read-only)
    debugger                Debug mode - investigate and fix
    watcher                 Background monitoring
    planner                 Planning and design (read-only)
    tester                  Testing and verification

EXAMPLES:
    agent spawn -n mywork -p ~/project
    agent spawn -t explorer --no-focus
    agent focus mywork
    agent focus 1
    agent status --watch
    agent search "error" -i
    agent kill mywork
    agent kill --all

PART OF DAEDALOS
    Tools designed BY AI, FOR AI development.
EOF
}

# Show version
show_version() {
    echo "agent $AGENT_VERSION"
}

# Main dispatch
main() {
    case "${1:-help}" in
        list)         shift; cmd_list "$@" ;;
        spawn)        shift; cmd_spawn "$@" ;;
        focus)        shift; cmd_focus "$@" ;;
        status)       shift; cmd_status "$@" ;;
        kill)         shift; cmd_kill "$@" ;;
        logs)         shift; cmd_logs "$@" ;;
        search)       shift; cmd_search "$@" ;;
        pause)        shift; cmd_pause "$@" ;;
        resume)       shift; cmd_resume "$@" ;;
        snapshot)     shift; cmd_snapshot "$@" ;;
        restore)      shift; cmd_restore "$@" ;;
        templates)    shift; cmd_templates "$@" ;;
        # External agent registration (Claude Code, etc.)
        register)     shift; cmd_register "$@" ;;
        unregister)   shift; cmd_unregister "$@" ;;
        whoami)       shift; cmd_whoami "$@" ;;
        # Communication commands
        send)         shift; cmd_send "$@" ;;
        inbox)        shift; cmd_inbox "$@" ;;
        request-help) shift; cmd_request_help "$@" ;;
        share)        shift; cmd_share "$@" ;;
        artifacts)    shift; cmd_artifacts "$@" ;;
        broadcast)    shift; cmd_broadcast "$@" ;;
        # Workflow commands
        workflow)     shift; cmd_workflow "$@" ;;
        # Group commands
        group)        shift; cmd_group "$@" ;;
        # Coordination commands
        signal)       shift; cmd_signal "$@" ;;
        lock)         shift; cmd_lock "$@" ;;
        claim)        shift; cmd_claim "$@" ;;
        # Lifecycle hooks
        hooks)        shift; cmd_hooks "$@" ;;
        version|--version|-v) show_version ;;
        help|--help|-h) show_help ;;
        *)         echo "Unknown command: $1"; show_help; exit 1 ;;
    esac
}

main "$@"
