name: agent
version: 1.0
created: 2025-01-11

intent: |
  Single agents hit walls. Multiple agents break through.

  The agent tool spawns and manages multiple Claude Code instances in
  tmux sessions. An orchestrator can spawn explorers, implementers,
  and reviewers - each focused on their specialty.

  The key insight: divide and conquer works for AI too. One agent
  explores while another implements. One debugs while another writes
  tests. Parallel specialized work beats serial generalist work.

  This is how complex tasks get done faster.

constraints:
  - Max 9 concurrent agents (mapped to Super+1-9)
  - Each agent gets dedicated tmux session
  - Agents must be isolated (separate project copies or scopes)
  - Spawning must be fast (< 5 seconds to active agent)
  - Cross-agent search must work in < 2 seconds
  - Works without tmux (degraded single-agent mode)

interface:
  commands:
    spawn:
      args: "-n <name> [-p <project>] [-t <template>] [--no-focus]"
      returns: "Creates new agent, reports slot and session"
      example: "agent spawn -n auth-impl -t implementer"

    list:
      args: "[--json] [--quiet]"
      returns: "Table of agents: slot, name, project, status, uptime"
      example: "agent list"

    focus:
      args: "<name|slot>"
      returns: "Switches tmux to specified agent"
      example: "agent focus 1"

    status:
      args: "[name] [--watch]"
      returns: "Detailed status: context usage, current task, activity"
      example: "agent status auth-impl --watch"

    kill:
      args: "<name|slot> [--force] [--all]"
      returns: "Gracefully stops agent, frees slot"
      example: "agent kill auth-impl"

    logs:
      args: "<name|slot> [-f] [-n lines]"
      returns: "Streams agent output"
      example: "agent logs auth-impl -f"

    search:
      args: "<query> [-a <agent>] [-i]"
      returns: "Searches across all agent outputs"
      example: "agent search 'authentication'"

    pause:
      args: "<name|slot>"
      returns: "Pauses agent (SIGSTOP)"
      example: "agent pause auth-impl"

    resume:
      args: "<name|slot>"
      returns: "Resumes paused agent (SIGCONT)"
      example: "agent resume auth-impl"

    snapshot:
      args: "[--all] [-n <snapshot-name>]"
      returns: "Saves agent states for restoration"
      example: "agent snapshot --all -n before-refactor"

    restore:
      args: "<snapshot>"
      returns: "Restores agents from snapshot"
      example: "agent restore before-refactor"

  exit_codes:
    0: success
    1: agent not found or operation failed
    2: max agents reached
    3: tmux not available

examples:
  - scenario: "Parallel feature development"
    context: "Complex feature needs exploration and implementation"
    action: |
      agent spawn -n explorer -t explorer
      agent spawn -n implementer -t implementer
    result: "Explorer researches while implementer builds"
    why_it_matters: "Research doesn't block implementation"

  - scenario: "Finding information across agents"
    context: "One agent found something, need to find it"
    action: "agent search 'authentication pattern'"
    result: |
      auth-impl:245  "implementing auth pattern from OAuth spec"
      explorer:89    "found auth patterns in Services/Auth/"
    why_it_matters: "Cross-agent knowledge is searchable"

  - scenario: "Quick agent switching"
    context: "Working with multiple agents on related tasks"
    action: "agent focus 2 (or Super+2)"
    result: "Instant switch to agent 2"
    why_it_matters: "Workflow isn't interrupted by context switching"

  - scenario: "Agent health monitoring"
    context: "Long-running agents, need to check progress"
    action: "agent status --watch"
    result: "Live dashboard of all agents' status"
    why_it_matters: "Orchestration requires visibility"

  - scenario: "Recovering from mistakes"
    context: "All agents went wrong direction"
    action: "agent restore before-refactor"
    result: "All agents restored to previous state"
    why_it_matters: "Multi-agent mistakes are recoverable"

decisions:
  - choice: "tmux for session management"
    why: |
      tmux provides:
      - Persistent sessions that survive disconnects
      - Built-in scrollback buffer (searchable logs)
      - Window/pane management already solved
      - Keybinding integration (Super+1-9)

      This isn't reinventing terminal multiplexing.
    alternatives:
      - option: "Custom terminal management"
        rejected_because: "Massive scope, tmux already perfect for this"
      - option: "Separate terminal windows"
        rejected_because: "No programmatic control, no persistence"
      - option: "Screen"
        rejected_because: "tmux has better scripting and status lines"

  - choice: "9 slots mapped to Super+1-9"
    why: |
      Human limit: tracking more than ~7 parallel contexts is hard.
      9 slots is generous but not overwhelming.

      Super+N keybindings make switching instant. No hunting
      through windows or remembering names.

  - choice: "Templates for common patterns"
    why: |
      Most agents fall into categories:
      - explorer: read-only, curious, maps codebase
      - implementer: full write access, builds features
      - reviewer: reads code, suggests improvements
      - debugger: investigates issues, verbose logging
      - watcher: background monitoring

      Templates encode best practices and permissions.
    alternatives:
      - option: "Always configure from scratch"
        rejected_because: "Friction, easy to forget important settings"
      - option: "Single universal agent type"
        rejected_because: "Specialization enables better prompts and permissions"

  - choice: "Centralized metadata in agents.json"
    why: |
      All agent info in one place enables:
      - Fast listing without querying tmux
      - Status tracking over time
      - Slot management logic
      - Snapshot/restore functionality

      JSON for simplicity - no database needed.

anti_patterns:
  - pattern: "Agents stepping on each other's files"
    why_bad: |
      Two agents editing the same file = chaos.
      Each agent should work in isolated scope or use file locking.
      git worktrees or scratch environments per agent.

  - pattern: "Spawning agents without purpose"
    why_bad: |
      Agents consume context and resources. Don't spawn speculatively.
      Each agent should have clear task from spawn time.

  - pattern: "Ignoring agent output"
    why_bad: |
      Agents generate insights. Search their output, don't just wait.
      agent search finds knowledge distributed across agents.

  - pattern: "Force-killing without snapshot"
    why_bad: |
      Lost work is lost forever. agent snapshot before bulk operations.
      kill --force should be rare.

  - pattern: "Running all agents on same project checkout"
    why_bad: |
      Race conditions on file writes. Use scratch or worktree per agent
      to ensure isolation. Only one implementer per checkout.

connects_to:
  - component: scratch
    relationship: |
      Each agent can get its own scratch environment.
      "agent spawn -n impl-1 --scratch" creates fresh isolated copy.
      Agent works in scratch, promotes if successful.

  - component: project
    relationship: |
      Agent spawn injects project info into initial context.
      Agents start oriented with architecture understanding.
      No wasted turns on "what is this codebase".

  - component: loop
    relationship: |
      Loop can orchestrate multi-agent workflows.
      "loop start --orchestrate" spawns explorer + implementer.
      Loop manages the coordination, agents do the work.

  - component: context
    relationship: |
      Agent status includes context usage per agent.
      Orchestrator can see which agents are nearing limits.
      Enables intelligent work distribution.

  - component: gates
    relationship: |
      Templates set gate permissions per agent type.
      Explorer gets read-only gates.
      Implementer gets write gates.

metrics:
  success_criteria:
    - "agent spawn completes in < 5 seconds"
    - "agent search returns in < 2 seconds across all agents"
    - "Complex tasks complete faster with multi-agent vs single"
    - "Zero file conflicts between concurrent agents"

  failure_indicators:
    - "Agents duplicating each other's work"
    - "File conflicts requiring manual resolution"
    - "Search too slow to be useful"
    - "Users falling back to single-agent mode"
