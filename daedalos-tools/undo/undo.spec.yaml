name: undo
version: 1.0
created: 2025-01-11

intent: |
  Users should experiment fearlessly. Every change is reversible.

  The undo system is a time machine, not a backup tool. It should feel
  instant and invisible until needed, then be there reliably. The mental
  model is simple: "I can always go back."

  The key insight: mistakes become cheap when reversal is instant. This
  changes how people work - they try more, fear less, iterate faster.
  An agent in a loop can make bold changes knowing any iteration can
  be unwound.

  This is foundational to Daedalos philosophy: iterate until done.
  Iteration requires cheap reversal.

constraints:
  - Must work without Btrfs (git-based fallback required)
  - Sub-second response for recent changes (< 100 entries)
  - No external dependencies beyond git and sqlite3
  - Works completely offline, no network required
  - Max 1GB storage per project by default
  - Atomic operations - never leave files in partial state
  - Never lose data silently - fail loudly if something goes wrong

interface:
  commands:
    timeline:
      args: "[-n count] [--file path] [--json]"
      returns: "Chronological list of changes with timestamps"
      example: "undo timeline -n 50"

    last:
      args: "[n] [--file path] [--dry-run]"
      returns: "Reverts last n changes, shows what was restored"
      example: "undo last 3"

    checkpoint:
      args: "[name]"
      returns: "Creates named restore point, confirms name"
      example: "undo checkpoint 'before-refactor'"

    restore:
      args: "<reference> [--file path] [--dry-run]"
      returns: "Restores to reference point (time, ID, or name)"
      example: "undo restore 12:42:00"

    diff:
      args: "<reference> [--file path] [--stat]"
      returns: "Shows diff from reference to current state"
      example: "undo diff 'pre-refactor'"

    watch:
      args: "[--project path]"
      returns: "Starts file watcher daemon for automatic tracking"
      example: "undo watch --project ."

  exit_codes:
    0: success
    1: undo failed (file not found, restore error)
    2: configuration error
    3: storage error (disk full, permissions)
    4: nothing to undo

examples:
  - scenario: "User breaks something during refactor"
    context: "Made 5 edits across 3 files, last one introduced a bug"
    action: "undo last"
    result: "Previous file state restored instantly, user sees which file changed"
    why_it_matters: "No mental overhead of git stash/checkout/reset. Just 'undo'."

  - scenario: "User wants to try risky approach"
    context: "About to delete half the codebase to simplify architecture"
    action: "undo checkpoint 'before-massacre'"
    result: "Named restore point created, user proceeds fearlessly"
    why_it_matters: "Encourages bold experimentation - the safety net is explicit"

  - scenario: "Agent is iterating in a loop"
    context: "Loop tool is running, making multiple fix attempts"
    action: "System auto-checkpoints at each iteration start"
    result: "Any iteration can be restored with 'undo restore iteration-3'"
    why_it_matters: "Loops become truly reversible, agents can be aggressive"

  - scenario: "User wants to see what changed"
    context: "Something broke but user doesn't know which edit caused it"
    action: "undo timeline --file src/auth.ts"
    result: "Shows all changes to that file with timestamps and descriptions"
    why_it_matters: "Debugging becomes archaeology - trace back through time"

  - scenario: "Restore to a specific time"
    context: "User knows code worked at 2pm, now it's broken"
    action: "undo restore 14:00"
    result: "All files restored to their 2pm state"
    why_it_matters: "Time-based thinking is natural - 'it worked an hour ago'"

decisions:
  - choice: "File-level granularity, not line-level"
    why: |
      Line-level sounds more precise but adds significant complexity.
      File-level matches the mental model better - "undo that edit" means
      the whole file, not specific lines. Users think in files.

      Btrfs CoW makes file copies nearly free anyway. The simplicity
      wins over theoretical precision that users rarely need.
    alternatives:
      - option: "Line-level patches (like git)"
        rejected_because: "Complex to implement correctly, fragile with concurrent edits, overkill for the use case"
      - option: "AST-level changes"
        rejected_because: "Language-specific, extremely complex, maintenance nightmare"

  - choice: "SQLite for metadata, filesystem for content"
    why: |
      SQLite gives us:
      - Fast indexed queries on timestamps and files
      - Atomic transactions (no corrupt state)
      - Single file to backup/move
      - Battle-tested reliability

      File content stays in filesystem (or git objects) because
      SQLite blob performance degrades with large content.
    alternatives:
      - option: "Pure filesystem (JSON files)"
        rejected_because: "No atomic writes, slow queries, hard to maintain indexes"
      - option: "Git notes/refs for everything"
        rejected_because: "Couples too tightly to git, weird semantics, hard to query"
      - option: "Full content in SQLite blobs"
        rejected_because: "Poor performance for large files, bloats database"

  - choice: "Hybrid storage with 100KB threshold"
    why: |
      Small files (< 100KB): Store inline in SQLite, compressed
      - Fast retrieval (single query)
      - Atomic with metadata
      - Most source files are small

      Large files (>= 100KB): Store as compressed files on disk
      - Better I/O performance
      - Doesn't bloat SQLite
      - Can use filesystem features (dedup on Btrfs)

      100KB threshold chosen empirically - covers 95%+ of source files
      while keeping database manageable.

  - choice: "Auto-checkpoint on restore (undo the undo)"
    why: |
      Before any restore operation, automatically create a checkpoint
      of current state. This means:
      - Undo is never destructive
      - User can undo their undo
      - Reduces fear of using undo

      The checkpoint is named 'pre-restore-HHMMSS' for clarity.

anti_patterns:
  - pattern: "Requiring users to name every checkpoint"
    why_bad: |
      Friction kills adoption. Most checkpoints are ephemeral safety nets,
      not meaningful milestones. Auto-generate names like 'checkpoint-20250111-143022'.
      Named checkpoints are opt-in for important moments.

  - pattern: "Showing raw git output"
    why_bad: |
      Leaks abstraction. Users chose 'undo' not 'git', they shouldn't see
      git internals. Translate to user-friendly messages.

  - pattern: "Prompting for confirmation on every undo"
    why_bad: |
      Undo should be instant and fearless. The safety net is 'undo the undo',
      not confirmation dialogs. Confirmations add friction and suggest danger
      where there is none.

  - pattern: "Losing data silently on storage errors"
    why_bad: |
      Better to fail loudly and refuse to proceed than silently skip
      a backup. User must know if their safety net has holes.

  - pattern: "Tracking files in .git or node_modules"
    why_bad: |
      Waste of storage, slows everything down, these are generated files.
      Respect .gitignore patterns by default.

  - pattern: "Blocking on file watcher startup"
    why_bad: |
      User shouldn't wait for daemon. Start async, buffer changes
      in memory until ready. First edit should feel instant.

connects_to:
  - component: loop
    relationship: |
      Loop creates automatic checkpoints at iteration boundaries.
      When loop starts: checkpoint 'loop-{name}-start'
      Each iteration: checkpoint 'loop-{name}-iter-{n}'
      This enables 'undo restore loop-fix-tests-iter-3'

  - component: scratch
    relationship: |
      Scratch environments share the same undo timeline within the env.
      When scratch is abandoned, its undo history is cleaned up.
      When scratch is promoted, undo history transfers to main project.

  - component: verify
    relationship: |
      When verify fails after recent edits, suggest:
      "Verification failed. Run 'undo last' to revert recent changes?"
      Provides a quick escape hatch from broken state.

  - component: gates
    relationship: |
      Gates can require checkpoint before destructive operations.
      If gates.file_delete requires approval, auto-checkpoint first.

metrics:
  success_criteria:
    - "undo last completes in < 100ms for recent changes"
    - "undo timeline displays in < 500ms for 1000 entries"
    - "Users use undo without hesitation (low friction)"
    - "Zero data loss incidents"
    - "Storage stays under configured limit"

  failure_indicators:
    - "Users reach for git commands instead"
    - "Storage grows faster than expected"
    - "Restore operations fail or produce corrupt state"
    - "Users ask 'is it safe to undo?'"
