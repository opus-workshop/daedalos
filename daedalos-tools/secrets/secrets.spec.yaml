name: secrets
version: 1.0
created: 2025-01-11

intent: |
  Secrets should be invisible until you need them.

  API keys, tokens, passwords - developers handle dozens of these.
  The temptation is to put them in .env files, commit them accidentally,
  paste them in Slack, store them in plaintext "just temporarily."
  Every shortcut is a future security incident.

  The secrets tool makes the right thing easy. Encrypted storage by
  default. Namespaced organization. Inject into environment only when
  needed, never persisted to disk in plaintext.

  The philosophy: secrets are first-class citizens, not afterthoughts.
  They have their own storage, their own commands, their own lifecycle.
  They're never part of your codebase, never in your shell history,
  never logged.

  For AI agents, this is critical. Agents need API keys to function
  but shouldn't have permanent access to them. secrets inject provides
  ephemeral access - the secret exists in the process environment
  only for the duration of the command, then it's gone.

  The encryption choice (age) is deliberate: modern, audited,
  single-purpose. Not GPG with its complexity. Not roll-your-own
  with its vulnerabilities. age does one thing well.

constraints:
  - All secrets encrypted at rest (age encryption)
  - Secrets never written to disk in plaintext
  - Never log or display secret values (except explicit get)
  - Must work completely offline (no cloud, no sync)
  - Compatible with standard environment variable patterns
  - Identity key stored securely (600 permissions)
  - Support namespacing for organization (api/, db/, etc.)
  - Single dependency: age (widely available, audited)

interface:
  commands:
    init:
      args: ""
      returns: "Initializes vault, generates identity key"
      example: "secrets init"

    set:
      args: "<KEY> [VALUE]"
      returns: "Secret stored (prompts if no value given)"
      example: "secrets set api/openai"

    get:
      args: "[-n] <KEY>"
      returns: "Secret value (or without newline with -n)"
      example: "secrets get api/openai"

    list:
      args: "[PREFIX] [--json]"
      returns: "All secret keys (not values)"
      example: "secrets list api"

    delete:
      args: "<KEY>"
      returns: "Secret removed"
      example: "secrets delete api/openai"

    env:
      args: "[PREFIX]"
      returns: "Export commands for secrets as env vars"
      example: "source <(secrets env api)"

    inject:
      args: "<COMMAND>"
      returns: "Runs command with all secrets in environment"
      example: "secrets inject 'npm start'"

    export:
      args: "[FILE]"
      returns: "Encrypted export of all secrets"
      example: "secrets export backup.age"

    import:
      args: "<FILE>"
      returns: "Import secrets from encrypted file"
      example: "secrets import backup.age"

    key:
      args: ""
      returns: "Shows public key for sharing"
      example: "secrets key"

  exit_codes:
    0: "Success"
    1: "Secret not found"
    2: "Encryption/decryption error"
    3: "age not installed"
    4: "Permission error"

examples:
  - scenario: "Storing an API key"
    context: "Developer got new OpenAI API key, needs to store it safely"
    action: "secrets set api/openai"
    result: "Prompts for value (hidden), encrypts, stores"
    why_it_matters: |
      Never type secrets in command line (visible in history).
      Never paste in plaintext files. The prompt is secure.

  - scenario: "Using secrets in development"
    context: "Running local server that needs API keys"
    action: "secrets inject 'npm run dev'"
    result: "Server starts with API_OPENAI, API_ANTHROPIC etc in env"
    why_it_matters: |
      Secrets exist only in the process, not in .env files.
      When the process exits, secrets are gone from memory.

  - scenario: "AI agent needing credentials"
    context: "Agent needs to call external API"
    action: "secrets inject 'agent run task'"
    result: "Agent has API access for this invocation only"
    why_it_matters: |
      Ephemeral access. Agent doesn't store the key, can't leak it,
      can't use it after the task completes.

  - scenario: "Sharing secrets with team"
    context: "New team member needs project secrets"
    action: "secrets export team-secrets.age (share securely)"
    result: "Encrypted file can be shared, imported on their machine"
    why_it_matters: |
      Secrets sharing that doesn't involve plaintext Slack messages.
      File is encrypted, safe to store in (private) shared location.

  - scenario: "Organizing many secrets"
    context: "Project uses multiple APIs, databases, services"
    action: "secrets set api/openai, secrets set db/prod, secrets list"
    result: "Secrets organized by namespace, easy to find and manage"
    why_it_matters: |
      Namespacing prevents chaos. 50 flat secrets is unmanageable.
      api/, db/, aws/, etc. creates natural organization.

decisions:
  - choice: "age encryption, not GPG"
    why: |
      age is modern, audited, and single-purpose:
      - X25519 key exchange
      - ChaCha20-Poly1305 authenticated encryption
      - Simple file format
      - No web of trust complexity

      GPG is powerful but complex - configuration footguns,
      subkey management, trust models. For encrypting secrets,
      we need simple and secure, not flexible and complex.
    alternatives:
      - option: "GPG encryption"
        rejected_because: "Complex setup, confusing key management, overkill"
      - option: "OpenSSL encryption"
        rejected_because: "Lower-level, easy to misuse, not key-based"
      - option: "Custom encryption"
        rejected_because: "Never roll your own crypto"
      - option: "Cloud-based secrets (Vault, AWS Secrets Manager)"
        rejected_because: "Requires network, account, not FOSS-pure"

  - choice: "Prompt for secret value, don't accept as argument"
    why: |
      Command line arguments are logged:
      - Shell history captures them
      - ps output shows them
      - Process monitoring reveals them

      Prompting with hidden input (read -s) avoids all these.
      Value still accepted as argument for scripting, but
      discouraged for interactive use.
    alternatives:
      - option: "Only accept as argument"
        rejected_because: "Insecure, leaves traces everywhere"
      - option: "Read from stdin"
        rejected_because: "Awkward UX, requires piping"
      - option: "Open editor for secret"
        rejected_because: "Overkill, potential temp file issues"

  - choice: "Filesystem-based vault, not database"
    why: |
      Each secret is a file: ~/.local/share/daedalos/secrets/vault/api/openai.age

      This provides:
      - Natural namespacing (directories)
      - Easy backup (copy directory)
      - Easy inspection (ls, find)
      - No database dependency

      age files are small, no performance concern.
    alternatives:
      - option: "SQLite database with encrypted blobs"
        rejected_because: "Adds dependency, harder to inspect and backup"
      - option: "Single encrypted file with all secrets"
        rejected_because: "Must decrypt entire vault to read one secret"
      - option: "Keyring integration (macOS Keychain, GNOME Keyring)"
        rejected_because: "Platform-specific, less portable"

  - choice: "Convert key names to env vars automatically"
    why: |
      Stored: api/openai
      Env var: API_OPENAI

      Convention: slashes become underscores, uppercase.
      This matches how most tools expect environment variables.

      No manual mapping needed - naming convention handles it.
    alternatives:
      - option: "Preserve exact key names"
        rejected_because: "api/openai isn't a valid env var name"
      - option: "Require explicit env var mapping"
        rejected_because: "Tedious, error-prone, unnecessary"
      - option: "Custom separator (double underscore)"
        rejected_because: "Less intuitive than simple underscore"

  - choice: "inject spawns subprocess, doesn't modify current env"
    why: |
      secrets inject runs the command in a new process with secrets
      in its environment. The parent shell never sees the secrets.

      This is safer than exporting to current shell:
      - Secrets don't persist after command exits
      - Secrets don't appear in shell's env
      - Secrets aren't inherited by other commands
    alternatives:
      - option: "Export to current shell"
        rejected_because: "Secrets persist, visible to subsequent commands"
      - option: "Modify /proc/PID/environ"
        rejected_because: "Requires elevated privileges, hacky"
      - option: "Source a temp file"
        rejected_because: "Temp file exists on disk, potential exposure"

anti_patterns:
  - pattern: "Putting secrets in .env files"
    why_bad: |
      .env files are plaintext, often committed to git accidentally,
      readable by any process, persist on disk.

      Use secrets set instead. The encryption is transparent.
      Use secrets inject to provide them to your app.

  - pattern: "secrets set api/key 'sk-1234...' (value in command)"
    why_bad: |
      Command line arguments are logged in shell history.
      Anyone with access to your history file sees the secret.

      Use: secrets set api/key (prompts for hidden input)

  - pattern: "Sharing identity key"
    why_bad: |
      Your identity key decrypts all your secrets.
      Never share it, never commit it, never backup to cloud.

      For sharing: export secrets, share encrypted file,
      recipient uses their own identity to re-encrypt.

  - pattern: "Using secrets for config, not just secrets"
    why_bad: |
      DATABASE_URL, API_ENDPOINT, DEBUG_MODE aren't secrets.
      They belong in environment config (.daedalos/env.sh).

      Secrets are for credentials: passwords, tokens, keys.
      Non-sensitive config should be in version control.

  - pattern: "Not namespacing secrets"
    why_bad: |
      openai, anthropic, postgres, prod-postgres, staging-postgres...
      Flat list becomes chaos quickly.

      Use: api/openai, api/anthropic, db/prod, db/staging
      List by namespace: secrets list api

  - pattern: "Checking secrets into git (even encrypted)"
    why_bad: |
      Encrypted secrets in git feel safe but aren't:
      - Key might leak later, exposing historical secrets
      - Rotation requires git history rewrite
      - Violates principle of secrets outside codebase

      Keep secrets in the vault, not in git.

connects_to:
  - component: env
    relationship: |
      env.sh should NOT contain secrets. Instead:

      # In .daedalos/env.sh
      source <(secrets env api)

      This loads secrets at environment activation time,
      never persisting them to disk.

  - component: gates
    relationship: |
      Gates always requires approval for:
      - Reading secret files
      - Any command containing "secret" or "password"
      - Access to ~/.local/share/daedalos/secrets/

      This prevents agents from exfiltrating secrets.

  - component: journal
    relationship: |
      Journal logs secret operations but NEVER values:
      "Secret set: api/openai"
      "Secret injected: 3 secrets for 'npm start'"

      Values are never logged anywhere.

  - component: agent
    relationship: |
      Agents receive secrets via inject:
      secrets inject 'agent run task'

      Agent has temporary access, cannot persist or extract.
      When task completes, secrets are gone.

  - component: session
    relationship: |
      Session explicitly excludes secrets from capture.
      Environment variables matching PASSWORD, TOKEN, etc.
      are filtered out.

      This prevents accidental secret capture in sessions.

  - component: backup
    relationship: |
      backup tool can include secrets vault (encrypted).
      The backup itself is encrypted, secrets doubly so.

      Restore requires both backup key and secrets identity.

metrics:
  success_criteria:
    - "Zero secrets in plaintext on disk"
    - "Zero secrets in shell history"
    - "Zero secrets logged or exposed"
    - "Users stop using .env files for secrets"
    - "Agents can access secrets without persisting them"

  failure_indicators:
    - "Secrets found in git history"
    - "Secrets in shell history files"
    - "Users bypass secrets tool for convenience"
    - "Identity key exposed or shared"
    - "Secrets persist after inject command completes"
