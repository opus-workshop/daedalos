#!/usr/bin/env bash
# secrets - Local secrets vault for Daedalos
#
# Secure storage for API keys, tokens, and credentials.
# Uses age encryption (https://age-encryption.org)

set -eo pipefail

SECRETS_VERSION="1.0.0"

# Data directories
DATA_DIR="${XDG_DATA_HOME:-$HOME/.local/share}/daedalos/secrets"
CONFIG_DIR="${XDG_CONFIG_HOME:-$HOME/.config}/daedalos"
VAULT_DIR="$DATA_DIR/vault"
KEYS_DIR="$DATA_DIR/keys"

mkdir -p "$VAULT_DIR" "$KEYS_DIR"
chmod 700 "$DATA_DIR" "$VAULT_DIR" "$KEYS_DIR"

# Colors
if [[ -t 1 ]]; then
    RED='\033[0;31m'
    GREEN='\033[0;32m'
    YELLOW='\033[0;33m'
    BLUE='\033[0;34m'
    CYAN='\033[0;36m'
    BOLD='\033[1m'
    DIM='\033[2m'
    NC='\033[0m'
else
    RED='' GREEN='' YELLOW='' BLUE='' CYAN='' BOLD='' DIM='' NC=''
fi

log_error() { echo -e "${RED}error:${NC} $*" >&2; }
log_success() { echo -e "${GREEN}âœ“${NC} $*"; }
log_warn() { echo -e "${YELLOW}!${NC} $*"; }
log_info() { echo -e "${BLUE}info:${NC} $*"; }

# Check for age encryption tool
check_age() {
    if ! command -v age &>/dev/null; then
        log_error "age encryption tool not found"
        echo ""
        echo "Install age:"
        echo "  macOS:  brew install age"
        echo "  Linux:  apt install age / nix-env -i age"
        echo "  Manual: https://github.com/FiloSottile/age"
        exit 1
    fi
}

# Get or create identity key
get_identity() {
    local key_file="$KEYS_DIR/identity.key"

    if [[ ! -f "$key_file" ]]; then
        log_info "Generating new identity key..."
        age-keygen -o "$key_file" 2>/dev/null
        chmod 600 "$key_file"
        log_success "Identity created"
    fi

    echo "$key_file"
}

# Get public key
get_recipient() {
    local key_file=$(get_identity)
    age-keygen -y "$key_file"
}

cmd_help() {
    cat << 'EOF'
secrets - Local secrets vault for Daedalos

USAGE:
    secrets <command> [args...]

COMMANDS:
    set <KEY> [VALUE]    Store a secret (prompts if no value)
    get <KEY>            Retrieve a secret
    list                 List all secret keys
    delete <KEY>         Delete a secret
    export [FILE]        Export secrets (encrypted)
    import <FILE>        Import secrets
    env [PREFIX]         Output as environment variables
    inject <CMD>         Run command with secrets in environment
    init                 Initialize vault (generates key)
    key                  Show public key for sharing

SECRET NAMING:
    Use namespaced keys for organization:
    - api/openai         OpenAI API key
    - api/anthropic      Anthropic API key
    - db/postgres        Database credentials
    - aws/access_key     AWS credentials

EXAMPLES:
    secrets set api/openai                  # Prompt for value
    secrets set api/openai "sk-..."         # Set directly
    secrets get api/openai                  # Retrieve
    secrets env api                         # Export api/* as env vars
    secrets inject "npm start"              # Run with all secrets

SECURITY:
    - Secrets are encrypted with age (X25519 + ChaCha20-Poly1305)
    - Identity key stored in ~/.local/share/daedalos/secrets/keys/
    - Vault stored in ~/.local/share/daedalos/secrets/vault/
    - Never logged or sent anywhere

INTEGRATION:
    Daedalos tools respect secrets:
    - gates: Always requires approval for secret file access
    - env: Can auto-load project-specific secrets
    - journal: Never logs secret values

EOF
}

cmd_init() {
    check_age

    local key_file="$KEYS_DIR/identity.key"

    if [[ -f "$key_file" ]]; then
        log_warn "Vault already initialized"
        echo "Public key: $(get_recipient)"
        return
    fi

    get_identity >/dev/null
    local pubkey=$(get_recipient)

    log_success "Vault initialized"
    echo ""
    echo "Your public key (for sharing encrypted secrets):"
    echo "  $pubkey"
    echo ""
    echo "Store secrets with: secrets set <key> <value>"
}

cmd_set() {
    check_age

    local key="$1"
    local value="$2"

    if [[ -z "$key" ]]; then
        log_error "Key name required"
        echo "Usage: secrets set <key> [value]"
        exit 1
    fi

    # Prompt for value if not provided
    if [[ -z "$value" ]]; then
        echo -n "Enter secret value: "
        read -rs value
        echo ""

        if [[ -z "$value" ]]; then
            log_error "Empty value not allowed"
            exit 1
        fi
    fi

    local identity=$(get_identity)
    local recipient=$(get_recipient)

    # Create key directory structure
    local key_dir=$(dirname "$VAULT_DIR/$key")
    mkdir -p "$key_dir"

    # Encrypt and store
    local secret_file="$VAULT_DIR/$key.age"
    echo -n "$value" | age -r "$recipient" -o "$secret_file"
    chmod 600 "$secret_file"

    log_success "Secret stored: $key"
}

cmd_get() {
    check_age

    local key="$1"
    local no_newline=false

    if [[ "$key" == "-n" ]]; then
        no_newline=true
        key="$2"
    fi

    if [[ -z "$key" ]]; then
        log_error "Key name required"
        exit 1
    fi

    local secret_file="$VAULT_DIR/$key.age"

    if [[ ! -f "$secret_file" ]]; then
        log_error "Secret not found: $key"
        exit 1
    fi

    local identity=$(get_identity)

    if [[ "$no_newline" == "true" ]]; then
        age -d -i "$identity" "$secret_file"
    else
        age -d -i "$identity" "$secret_file"
        echo ""
    fi
}

cmd_list() {
    local as_json=false
    local prefix=""

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --json) as_json=true; shift ;;
            *) prefix="$1"; shift ;;
        esac
    done

    local search_dir="$VAULT_DIR"
    [[ -n "$prefix" ]] && search_dir="$VAULT_DIR/$prefix"

    if [[ ! -d "$search_dir" ]] && [[ ! -d "$VAULT_DIR" ]]; then
        if [[ "$as_json" == "true" ]]; then
            echo "[]"
        else
            echo "No secrets stored"
        fi
        return
    fi

    if [[ "$as_json" == "true" ]]; then
        echo "["
        local first=true
        find "$VAULT_DIR" -name "*.age" -type f 2>/dev/null | while read -r file; do
            local key="${file#$VAULT_DIR/}"
            key="${key%.age}"
            [[ "$first" == "true" ]] || echo ","
            first=false
            echo "  \"$key\""
        done
        echo "]"
        return
    fi

    echo -e "${BOLD}Stored Secrets${NC}"
    echo ""

    find "$VAULT_DIR" -name "*.age" -type f 2>/dev/null | sort | while read -r file; do
        local key="${file#$VAULT_DIR/}"
        key="${key%.age}"

        # Group by namespace
        local namespace="${key%%/*}"
        local name="${key#*/}"

        echo -e "  ${CYAN}$key${NC}"
    done
}

cmd_delete() {
    local key="$1"

    if [[ -z "$key" ]]; then
        log_error "Key name required"
        exit 1
    fi

    local secret_file="$VAULT_DIR/$key.age"

    if [[ ! -f "$secret_file" ]]; then
        log_error "Secret not found: $key"
        exit 1
    fi

    # Secure delete
    rm -f "$secret_file"

    # Clean up empty directories
    local key_dir=$(dirname "$secret_file")
    while [[ "$key_dir" != "$VAULT_DIR" ]] && [[ -d "$key_dir" ]] && [[ -z "$(ls -A "$key_dir")" ]]; do
        rmdir "$key_dir"
        key_dir=$(dirname "$key_dir")
    done

    log_success "Secret deleted: $key"
}

cmd_env() {
    check_age

    local prefix="${1:-}"
    local export_cmd="${2:-export}"

    local identity=$(get_identity)
    local search_dir="$VAULT_DIR"
    [[ -n "$prefix" ]] && search_dir="$VAULT_DIR/$prefix"

    if [[ ! -d "$search_dir" ]]; then
        return
    fi

    find "$search_dir" -name "*.age" -type f 2>/dev/null | while read -r file; do
        local key="${file#$VAULT_DIR/}"
        key="${key%.age}"

        # Convert key to env var name (replace / with _, uppercase)
        local env_name=$(echo "$key" | tr '/' '_' | tr '[:lower:]' '[:upper:]')

        local value=$(age -d -i "$identity" "$file" 2>/dev/null)

        if [[ -n "$value" ]]; then
            echo "$export_cmd $env_name='$value'"
        fi
    done
}

cmd_inject() {
    check_age

    local cmd="$*"

    if [[ -z "$cmd" ]]; then
        log_error "Command required"
        echo "Usage: secrets inject <command>"
        exit 1
    fi

    local identity=$(get_identity)

    # Build environment
    local env_vars=""
    find "$VAULT_DIR" -name "*.age" -type f 2>/dev/null | while read -r file; do
        local key="${file#$VAULT_DIR/}"
        key="${key%.age}"
        local env_name=$(echo "$key" | tr '/' '_' | tr '[:lower:]' '[:upper:]')
        local value=$(age -d -i "$identity" "$file" 2>/dev/null)
        export "$env_name=$value"
    done

    # Run command
    exec env $(cmd_env "" "env") $cmd
}

cmd_export() {
    check_age

    local output="${1:-secrets_export.age}"

    # Create tarball of vault and encrypt
    tar -cf - -C "$DATA_DIR" vault 2>/dev/null | age -r "$(get_recipient)" -o "$output"

    log_success "Secrets exported to: $output"
    echo "Share this file securely. Recipient needs your identity key to decrypt."
}

cmd_import() {
    check_age

    local file="$1"

    if [[ -z "$file" ]] || [[ ! -f "$file" ]]; then
        log_error "Import file required"
        exit 1
    fi

    local identity=$(get_identity)

    # Decrypt and extract
    age -d -i "$identity" "$file" | tar -xf - -C "$DATA_DIR"

    log_success "Secrets imported"
}

cmd_key() {
    check_age
    get_recipient
}

main() {
    local cmd="${1:-help}"

    case "$cmd" in
        help|--help|-h)
            cmd_help
            ;;
        init)
            cmd_init
            ;;
        set|add|store)
            shift
            cmd_set "$@"
            ;;
        get|show|read)
            shift
            cmd_get "$@"
            ;;
        list|ls)
            shift
            cmd_list "$@"
            ;;
        delete|rm|remove)
            shift
            cmd_delete "$@"
            ;;
        env)
            shift
            cmd_env "$@"
            ;;
        inject|run|exec)
            shift
            cmd_inject "$@"
            ;;
        export)
            shift
            cmd_export "$@"
            ;;
        import)
            shift
            cmd_import "$@"
            ;;
        key|pubkey)
            cmd_key
            ;;
        version|--version|-V)
            echo "secrets $SECRETS_VERSION"
            ;;
        *)
            log_error "Unknown command: $cmd"
            echo "Run 'secrets help' for usage"
            exit 1
            ;;
    esac
}

main "$@"
